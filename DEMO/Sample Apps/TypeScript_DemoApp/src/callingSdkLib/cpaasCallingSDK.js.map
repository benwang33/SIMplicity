{
  "version": 3,
  "sources": ["../src/common/api/version.ts", "../src/common/libs/utils.ts", "../src/common/api/emergencyNumbers.ts", "../src/common/libs/line-utils.ts", "../src/common/libs/Logger.ts", "../src/code/utilities/ToneHelper.ts", "../src/code/utilities/utils.ts", "../src/api/Call.ts", "../src/common/libs/SimplePubSub.ts", "../src/code/calling/WebRtcAPIs.ts", "../src/code/calling/DaasCallingAPIs.ts", "../src/code/calling/Call.ts", "../src/code/calling/CallManager.ts", "../src/code/index.ts"],
  "sourcesContent": ["export const commonVersion = '0.1.0'\n", "/**\n * General Utility functions that can be used any any code area\n */\n\nimport { Logger } from './Logger'\n\nconst userAgentData = navigator['userAgentData']\n\n//////////////////////////////////////\nexport const wrgErrorCodes = {\n  0: 'Unspecified Registration error.',\n  400: 'Check logout flow',\n  401: 'Check logout flow',\n  403: 'Check register error flow',\n  404: 'Check rejoin/other APIs which for special handling. Generic behavior logout flow',\n  405: 'Operation is not allowed by WRG on this resource.',\n  408: 'Request Timed-out',\n  409: 'Too many other active registrations with same credentials.',\n  420: 'Redirect user to IAM on browser, get new WRG auth code, and call uccRegister on OTT',\n  500: 'Check register error flow',\n  501: 'Flow is not implemented by WRG.',\n  503: 'Service Not Available',\n  603: 'Websocket connection failure',\n}\n\n/////////////////////////////////////\nexport function secureMathRandom(): number {\n  // Use this method instead of Math.random()\n  // Divide a random UInt32 by the maximum value (2^32 -1) to get a result between 0 and 1\n  return window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295\n}\n\n/////////////////////////////\n// export function secureRandom(): number {\n//   return crypto.getRandomValues(new Uint32Array(1))[0]\n// }\n\n/**\n * Creates a new object and copy the enumerable property values of `obj` into it, without the ones\n * specified by `excluding`.\n *\n * @param {Object} obj\n * @param {string[]} excluding\n * @returns {Object} The newly created object, as specified above.\n */\nexport function shallowCopy(obj: any, excluding?: string[]): any {\n  const result = Object.assign({}, obj)\n  if (excluding) {\n    excluding.forEach((excl) => delete result[excl])\n  }\n  return result\n}\n\n/**\n * Gets the attribute by name.\n * Returns the 'value' array associated with the 'name'\n *\n * @param obj\n * @param attriName\n */\nexport function getAttributeValue(obj: any, attriName: string): string[] {\n  if (obj && obj.attributes && obj.attributes.attribute) {\n    for (const attribute of obj.attributes.attribute) {\n      if (attribute.name === attriName) {\n        return attribute.value\n      }\n    }\n  }\n  return [] // attribute could not be found\n}\n\n/**\n *\n */\nexport interface MapOf<T> {\n  [key: string]: T\n}\n\n/**\n * checks if the specified bit is on in the testValue\n *\n * @param {number} testValue\n * @param {number} bit\n */\nexport function checkBIT(testValue: number, bit: number): boolean {\n  return (testValue & bit) !== 0\n}\n\n/**\n * NOOP\n */\nexport function noop(): string {\n  return 'noop'\n}\n\n/**\n * Attempts to run the function provided by `fn` for `maxRetries` times, with an exponential backoff rate of 2. <br>\n * Once execution has completed, either the `resolve` or `reject` function is called, to resolve the returned promise\n * or reject it if an error occurred.\n * @param name\n * @param fn\n * @param L\n * @param maxRetries\n * @param initialBackoff\n * @param failureCallback\n */\nexport const expoRetry = <T>(\n  name: string,\n  fn: () => T | Promise<T>,\n  L?: Logger,\n  maxRetries: number = 2,\n  initialBackoff: number = 1000,\n  failureCallback?: () => void\n): Promise<T> => {\n  return new Promise((resolve, reject) => {\n    let count = 0\n    let backoff = initialBackoff\n\n    const whenError = (error: any): void => {\n      count++\n      if (count >= maxRetries) {\n        if (L) {\n          L.log(`${name}: try#${count}->failed, too many retries`)\n          if (L && failureCallback) {\n            failureCallback()\n          }\n        }\n        reject(error)\n      } else {\n        if (L) {\n          L.log(`${name}: try#${count - 1}->failed, retry in ${backoff}.  Error:`, error)\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        window.setTimeout(doTry, backoff)\n        backoff = backoff * 2\n      }\n    }\n    const doTry = (): void => {\n      try {\n        if (L) {\n          L.log(`${name}: try#:${count + 1}/${maxRetries}`)\n        }\n        const result = fn()\n\n        if (result instanceof Promise) {\n          const resultPromise: Promise<T> = result\n          resultPromise.then(resolve).catch(whenError)\n        } else {\n          if (L) {\n            L.log(`${name}: try#${count}->success`)\n          }\n          resolve(result)\n        }\n      } catch (err) {\n        whenError(err)\n      }\n    }\n\n    doTry()\n  })\n}\n\n/**\n *\n * @param tg\n * @param props\n * @param createChildren\n */\nexport function findProperty(tg: any, props: string | string[], createChildren: boolean = false): any {\n  if (!Array.isArray(props)) {\n    props = props.split('.')\n  }\n\n  let childsParent = tg\n  for (const k of props) {\n    if (childsParent[k]) {\n      childsParent = childsParent[k]\n    } else {\n      if (createChildren) {\n        childsParent[k] = {}\n        childsParent = childsParent[k]\n      } else {\n        return undefined\n      }\n    }\n  }\n\n  return childsParent\n}\n\n/**\n *\n * @param target\n * @param {string} propSelector\n * @param value\n */\nexport function setFieldValue(target: any, propSelector: string, value: any): void {\n  if (!target || !propSelector) {\n    return\n  }\n\n  const props = propSelector.trim().split('.')\n  const fieldName = props.pop()\n\n  const cParent = findProperty(target, props, true)\n\n  if (value === undefined) {\n    delete cParent[fieldName]\n  } else {\n    cParent[fieldName] = value\n  }\n}\n\n/**\n *\n * @param target\n * @param {string} propSelector\n * @param defaultValue\n * @returns {any}\n */\nexport function getFieldValue(target: any, propSelector: string, defaultValue: any = undefined): any {\n  if (!target || !propSelector || 'string' !== typeof propSelector) {\n    return defaultValue\n  }\n\n  const props = propSelector.trim().split('.')\n  let tmp = target\n  for (const propName of props) {\n    tmp = tmp[propName]\n    if (!tmp) {\n      break\n    }\n  }\n\n  return tmp ? tmp : defaultValue\n}\n\n/**\n *\n * @param tg\n * @param propSelector\n */\nexport function deleteField(tg: any, propSelector: string): void {\n  const props = propSelector.trim().split('.')\n  if (props.length === 1) {\n    delete tg[props[0]]\n  } else {\n    const lastKey = props.slice(props.length - 1, 1)[0]\n    const parent = findProperty(tg, props, true)\n    delete parent[lastKey]\n  }\n  findProperty(tg, props)\n}\n\n/**\n * Renames fields in target according to the renaming table\n *\n * @param tg\n * @param {string[][]} renamingTable\n * @returns {any}\n */\nexport function renameFields(tg: any, renamingTable: string[][]): any {\n  if (renamingTable) {\n    renamingTable.forEach((k1k2) => {\n      setFieldValue(tg, k1k2[1], getFieldValue(tg, k1k2[0]))\n      deleteField(tg, k1k2[0])\n    })\n  }\n\n  return tg\n}\n\n/**\n * steals fields from the src to the specified tg\n * if the renaming table is specified, the fields in target will be renamed accordingly\n *\n * @param tg\n * @param src\n * @param {string[][]} renamingTable\n * @returns {any}\n */\nexport function stealFields(tg: any, src: any, renamingTable?: string[][]): any {\n  return renameFields(Object.assign(tg, src), renamingTable)\n}\n\n/**\n *\n * @param arr\n * @param key\n */\nexport function dedupArray(arr: any[], key: (...args: any) => PropertyKey): any[] {\n  const formattedArray = {}\n  return arr.filter((item) => {\n    const k = key(item)\n    // eslint-disable-next-line no-prototype-builtins\n    return formattedArray.hasOwnProperty(k) ? false : (formattedArray[k] = true)\n  })\n}\n\n/**\n * isElectron\n *\n * @type {boolean}\n */\nexport function isRunningOnElectron(): boolean {\n  return navigator.userAgent.toLowerCase().includes('electron')\n}\n\n/**\n * tests if running on localhost\n */\nexport function isLocalEnv(): boolean {\n  return isRunningOnElectron() || window.location.origin.includes('localhost')\n}\n\n/**\n * Is running as a PWA app\n */\nexport function isRunningAsPWA(): boolean {\n  const mqStandAlone = '(display-mode: standalone)'\n  return navigator['standalone'] || window.matchMedia(mqStandAlone).matches\n}\n\n/**\n * Browser simple name: Edge/Chrome/Firefox\n *\n * @returns {string | undefined}\n */\nexport function getPlatformBrowser(): string | undefined {\n  // Try-catch necessary for unit tests to pass\n  const desktop = 'DIGITS from T-Mobile'\n  try {\n    return ['Electron', 'Edg', 'Chrome', 'Firefox', 'Safari']\n      .find((plat) => navigator.userAgent.includes(plat))\n      .replace('Electron', desktop)\n      .replace('Edg', 'Edge')\n  } catch (e) {\n    return desktop\n  }\n}\n\n/**\n * OS simple name\n *\n * @returns {string | undefined}\n */\nexport function getPlatformOS(): string {\n  return ['Mac', 'Windows', 'Linux'].find((b) => navigator.userAgent.indexOf(b) >= 0)\n}\n\n/**\n *\n */\nexport function isMacOS(): boolean {\n  return getPlatformOS() === 'Mac'\n}\n\n/**\n *\n * @param arr\n * @param el\n * @param equals\n */\nexport function indexOf<T>(arr: T[], el: T, equals?: (o1: T, o2: T) => boolean): number {\n  return !equals\n    ? arr.indexOf(el)\n    : ((): number => {\n        for (let i = 0; i < arr.length; i++) {\n          if (equals(arr[i], el)) {\n            return i\n          }\n        }\n        return -1\n      })()\n}\n\n/**\n * Determine the mobile phone platform: Android, iPhone, iPad, iPod or other (undefined).\n * We only support apps for Android and iOS.\n */\nexport function mobilePlatform(): string {\n  // navigator.platform is deprecated, so search for platform hints within the userAgent\n  const foundPlatform = ['Android', 'iPhone', 'iPad', 'iPod'].find((plat) => navigator.userAgent.includes(plat))\n  if (foundPlatform) {\n    return foundPlatform\n  } else if (userAgentData?.mobile) {\n    return userAgentData.platform\n  }\n  return ''\n}\n\n/**\n * Evaluates input parameter to see if its type is 'function'\n * @param fn\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(fn: Function): boolean {\n  return typeof fn === 'function'\n}\n\n/**\n * Returns true if the specified any is thenable (has the `then` function, like a promise)\n * @param value\n * @returns {boolean}\n */\nexport function isThenable(value: any): boolean {\n  return !!value && value === Object(value) && isFunction(value.then)\n}\n\n/**\n * function that returns a promise of any\n */\nexport type PromiseFunction = (...args: any[]) => Promise<any>\n\n/**\n * Run\n *\n * @param {PromiseFunction[]} funcs\n * @param ctx\n * @returns {Promise<any>}\n */\nexport function runInChain(funcs: PromiseFunction[], ctx?: any): Promise<any> {\n  return funcs.reduce(\n    (promise: Promise<any>, func: PromiseFunction) =>\n      promise.then((result) => (ctx ? func(ctx) : func()).then(Array.prototype.concat.bind(result))),\n    Promise.resolve([])\n  )\n}\n\n/**\n * Checks if the two specified arrays are equal\n *\n * @param {ArrayLike<any>} a1\n * @param {ArrayLike<any>} a2\n * @returns {boolean}\n */\nexport function arrEq(a1: ArrayLike<any>, a2: ArrayLike<any>): boolean {\n  if (a1 === null) {\n    return a2 === null\n  }\n  if (a1.length !== a2.length) {\n    return false\n  }\n  for (let k = 0; k < a1.length; k++) {\n    if (a1[k] !== a2[k]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Promise based timeout\n * @param ms\n */\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    window.setTimeout(() => {\n      resolve()\n    }, ms)\n  })\n}\n\n/**\n * Formal method to clone an array\n * @param {any[]} arr\n * @returns {any[]}\n */\nexport function cloneArr(arr: any[]): any[] {\n  return arr.slice(0)\n}\n\n/**\n *\n * @param map\n * @param iterator\n * @param initialACC\n */\nexport const reduceMap = <K, V, T>(map: Map<K, V>, iterator: (k: K, v: V, accumulator: T) => T, initialACC: T): T => {\n  let acc = initialACC\n\n  if (!map.entries) {\n    return initialACC\n  }\n\n  map.forEach((v: V, k: K) => {\n    acc = iterator(k, v, acc)\n  })\n\n  return acc\n}\n\n/**\n *\n * @param map\n */\nexport const map2Object = <V>(map: Map<string, V>): MapOf<V> =>\n  reduceMap(\n    map,\n    (k: string, v: V, acc: MapOf<V>) => {\n      acc[k] = v\n      return acc\n    },\n    {}\n  )\n\n/**\n * Scrub the base64 content of CR-LF char pairs\n * Then convert base64 to binary string\n * @param base64Str\n */\nexport function atobScrubbedData(base64Str: string): string {\n  return window.atob(base64Str.replace(/\\r\\n/g, ''))\n}\n\n/**\n * Converts base64 encoded  Data URL\n * @param dataArray\n * @param mime\n * @param isBase64\n */\nexport function dataToBlob(dataArray: string, mime?: string, isBase64?: boolean): Blob {\n  if (!dataArray || dataArray.length === 0) {\n    throw new Error('No DataURL or DataURL is empty')\n  }\n\n  const arr = dataArray.split(',')\n  const newMime = mime ? mime : arr[0].match(/:(.*?);/)[1]\n\n  let bstr\n  if (typeof isBase64 !== 'undefined') {\n    // isBase64 is specified.  Try just one way\n    bstr = isBase64 ? atobScrubbedData(dataArray) : atobScrubbedData(arr[1])\n  } else {\n    // isBase64 is unknown or unspecified, try both ways.\n    try {\n      bstr = atobScrubbedData(dataArray)\n    } catch (e) {\n      bstr = atobScrubbedData(arr[1])\n    }\n  }\n\n  let n = bstr.length\n  const u8arr = new Uint8Array(n)\n\n  while (n-- > 0) {\n    u8arr[n] = bstr.charCodeAt(n)\n  }\n  return new Blob([u8arr], { type: newMime })\n}\n\n/**\n * Convert Base 64 string to UTF-8 Unicode.  Necessary for proper decoding of emojis in strings.\n * Borrowed from StackOverflow article:\n * https://stackoverflow.com/questions/30106476/using-javascripts-atob-to-decode-base64-doesnt-properly-decode-utf-8-strings/30106551#30106551\n *\n * @param base64Str\n */\nexport function decodeBase64toUnicode(base64Str: string): string {\n  const text = atobScrubbedData(base64Str)\n  const length = text.length\n  const bytes = new Uint8Array(length)\n  for (let i = 0; i < length; i++) {\n    bytes[i] = text.charCodeAt(i)\n  }\n  const decoder = new TextDecoder() // default is utf-8\n  return decoder.decode(bytes)\n}\n\nfunction stringSanitizer(dirtyString: string): string {\n  // eslint-disable-next-line no-control-regex\n  return dirtyString.replace(/[\\u0000-\\u001F]/gim, (character) => {\n    return `\\\\u${character.codePointAt(0).toString(16).padStart(4, '0')}`\n  })\n}\n\n// This method parses a JSON formatted string, and returns the JSON (or\n// undefined) along with the success of the parsing in a single object.\nfunction parseJSONHelper(msg: string): { data: any; success: boolean } {\n  try {\n    const data = JSON.parse(msg)\n    return {\n      data: data,\n      success: true,\n    }\n  } catch (e) {\n    return {\n      data: undefined,\n      success: false,\n    }\n  }\n}\n\n/**\n * This method tries to parse the string into a valid JSON object, and in\n * the cases where it fails (which should be very uncommon) tries to escape\n * any characters that are causing the parse to fail, then returns the\n * result of retrying the parsing.\n * @param str\n */\nexport function parseJSON(str: string): { data: any; success: boolean } {\n  if (typeof str !== 'string' || !str.length) {\n    return {\n      data: undefined,\n      success: false,\n    }\n  }\n  let data = parseJSONHelper(str)\n  if (!data.success) {\n    const cleanedString = stringSanitizer(str)\n    data = parseJSONHelper(cleanedString)\n  }\n  return data\n}\n\nlet privateIsSystemOnLine = false\n/**\n * Convenient means for reading the system online state determined by the connectionMonitor\n * without having to pass in values or know anything about the connectionMonitor\n */\nexport function isSystemOnline(): boolean {\n  return privateIsSystemOnLine\n}\n\n/**\n *\n * @param newState\n */\nexport function setSystemOnline(newState: boolean): void {\n  privateIsSystemOnLine = newState\n}\n\n/**\n *\n * @param day1\n * @param day2\n */\nexport function isSameDay(day1: string, day2: string): boolean {\n  const d1 = new Date(Date.parse(day1))\n  const d2 = new Date(Date.parse(day2))\n  return d1.getDate() === d2.getDate() && d1.getMonth() === d2.getMonth() && d1.getFullYear() === d2.getFullYear()\n}\n\n/**\n * should return true if timestamps are within 5 minutes or custom diff if specified\n * @param day1\n * @param day2\n * @param diff\n */\nexport function isWithinTimeDiff(day1: string, day2: string, diff: number = 5 * 60 * 1000): boolean {\n  const d1 = Date.parse(day1)\n  const d2 = Date.parse(day2)\n  return Math.abs(d1 - d2) <= diff\n}\n\n/**\n *\n */\nexport interface ApiStatus {\n  data?: any\n  error?: any\n  headers?: Headers\n  ok: boolean\n  status: number\n  statusText: string\n}\n\n/**\n *\n * @param statusText\n * @param status\n * @param error\n */\nexport const makeApiError = (statusText: string, status?: number, error?: any): ApiStatus => {\n  return { ok: false, statusText, status: status || 4000, error } as ApiStatus\n}\n\n/**\n *\n */\nexport const makeApiSuccess = (): ApiStatus => {\n  return { ok: true, statusText: 'success', status: 200 } as ApiStatus\n}\n\n/**\n *\n * @param str\n */\nexport const toTitleCase = (str: string): string => {\n  return str.replace(/\\w\\S*/g, (txt) => {\n    return txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase()\n  })\n}\n\n/**\n * Convert string to camel case if using hyphened or underscore separators.\n * @param str\n */\nexport function toCamelCase(str: string): string {\n  return str.replace(/([-_][a-z])/gi, ($1) => {\n    return $1.toUpperCase().replace('-', '').replace('_', '')\n  })\n}\n\n/**\n *\n * @param obj\n */\nexport function isObject(obj: any): boolean {\n  return typeof obj === 'object' && !Array.isArray(obj)\n}\n\n///////////////////////////////////////\nexport function objectKeysToCamel(input: any): any {\n  if (isObject(input)) {\n    const newObj = {}\n    const keys = Object.keys(input)\n    for (const key of keys) {\n      newObj[toCamelCase(key)] = objectKeysToCamel(input[key])\n    }\n    return newObj\n  } else if (Array.isArray(input)) {\n    return input.map((ix): any => {\n      return objectKeysToCamel(ix)\n    })\n  }\n\n  return input\n}\n\nexport function transformOctalCode(code: string): string {\n  return code.replace(/\\\\([0-7]{3})/g, function (_part1: string, part2: string) {\n    return String.fromCharCode(parseInt(part2, 8))\n  })\n}\n\n// Translates escaped unicode used for emojis into printable characters\nexport function transformUnicode(str: string): string {\n  if (!str) {\n    return ''\n  }\n  str = transformOctalCode(str)\n  return decodeURIComponent(JSON.parse('\"' + str.replace(/\\\"/g, '\\\\\"') + '\"'))\n}\n\n///////////////////////////////////////\nexport function getUserId(): string {\n  const length = 16\n  return Math.round(Math.pow(36, length + 1) - secureMathRandom() * Math.pow(36, length))\n    .toString(36)\n    .slice(1)\n}\n\n///////////////////////////////////////\nexport function generateUUID(): string {\n  let d = new Date().getTime()\n  if (window.performance && isFunction(window.performance.now)) {\n    d += performance.now()\n  }\n  const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (d + secureMathRandom() * 16) % 16 | 0\n    d = Math.floor(d / 16)\n    return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16)\n  })\n  return uuid\n}\n\n///////////////////////////////////////\nexport function extractErrorMessages(errorObj: any): string {\n  if (typeof errorObj === 'string') {\n    return errorObj\n  }\n  let eMsg = ''\n  if (errorObj.message) {\n    eMsg = errorObj.message\n  } else if (errorObj.statusText) {\n    eMsg = errorObj.statusText\n    if (errorObj.error && errorObj.error.message) {\n      eMsg += ` :: ${errorObj.error.message}`\n    }\n  }\n  return eMsg\n}\n\n///////////////////////////////////////\nexport function getCurrentUTCDateTimeStr(includeMs?: boolean): string {\n  // Creates a standard UTC date-time string in the format:\n  // YYYY-MM-DDTHH:MM:SSZ\n  // or\n  // YYYY-MM-DDTHH:MM:SS.mmmZ\n  const fullIsoStr = new Date().toISOString()\n  if (includeMs) {\n    return fullIsoStr\n  }\n  // short from - remove last five characters, and then append the final 'Z'\n  return fullIsoStr.slice(0, -5) + 'Z'\n}\n\n/**\n * Device name as in \"Desktop -\n *\n * @param userFirstName\n * @returns {string}\n */\nexport function getDeviceName(): string {\n  const browser = getPlatformBrowser()\n  const eABridge = getFieldValue(window, 'ElectronBridge')\n\n  let hostName\n  if (eABridge && isFunction(eABridge.getHostname)) {\n    hostName = eABridge.getHostname()\n  }\n  const os = getPlatformOS()\n  let deviceName\n  if (hostName) {\n    deviceName = `${hostName}-${os}-Desktop-App`\n  } else {\n    deviceName = `${os}-${browser}-Browser`\n    if (isRunningAsPWA()) {\n      deviceName += `-Installed-App`\n    }\n  }\n  return deviceName\n}\n\n/////////////////////////////////////////////////\n// Return the last segment of a multipart url\n// ie returns 'zee' for input url: \"https://t-mobile.com/x/y/zee\"\nexport function getLastUrlSegment(url: string): string {\n  if (!url || typeof url !== 'string') {\n    return undefined\n  }\n  const index = url.lastIndexOf('/')\n  if (index === -1) {\n    // input string does not have a url segment divider.  Just return the input\n    return url\n  }\n  return url.substring(index + 1)\n}\n", "/**\n * Array of the emergency numbers used in calling and messaging\n *\n * @type {string[]}\n */\nexport const emergencyNumbers = [\n  '+1112',\n  '+112',\n  '+1911',\n  '+1912',\n  '+911',\n  '+912',\n  '00112',\n  '00911',\n  '00912',\n  '0112',\n  '0911',\n  '0912',\n  '1112',\n  '112',\n  '1911',\n  '1912',\n  '911',\n  '912',\n  '922',\n]\n", "/**\n * Common Utility methods for line management.\n */\n\nimport { Line, LineType, URI } from '../api/commontypes'\nimport { secureMathRandom } from './utils'\nimport { emergencyNumbers } from '../api/emergencyNumbers'\nimport { ussdCodes } from '../api/ussdCodes'\n\nexport const removeChar = (msisdn: string, char: string): string => msisdn.replace(char, '')\n\n/**\n * Returns the line type for the specified URI\n *\n * cryptic code inherited from eDigits code (UtilsService.getInputType)\n * Used to determine if line was a number or email.\n *\n * @param {string} _uri\n * @returns {}\n */\nexport const lineTypeFromURI = (_uri: string): LineType => {\n  // C-Digits currently only supports the 'number' LineType\n  return 'number'\n}\n\n/**\n *\n * @param phoneNumber\n */\nexport const isEmergencyNumber = (phoneNumber: string): boolean => !!emergencyNumbers.find((en) => en === phoneNumber)\n\n/**\n *\n * @param number\n */\nexport const isUSSDCode = (number: string): boolean => !!ussdCodes.find((ussd) => ussd === number)\n\n/**\n *\n * @param phone\n */\nexport const normalizePhoneNumber = (phone: string): string => {\n  if (typeof phone !== 'string' || !phone.length) {\n    return phone\n  }\n\n  // strip out everything except the digits and a possible leading plus\n  const m = phone.match(/^\\+|\\d/g)\n  const strippedNumber = m ? m.join('') : ''\n  if (strippedNumber.startsWith('+')) {\n    // number is in international format, keep it as it is\n    return strippedNumber\n  }\n  if (strippedNumber.length === 10) {\n    // no country code and 10 digits, assume it's a US number\n    return '+1' + strippedNumber\n  }\n  if (strippedNumber.length === 11 && strippedNumber.startsWith('1')) {\n    // 10 digits after a leading '1', assume it's a US number\n    return '+' + strippedNumber\n  }\n  return strippedNumber\n}\n\n/**\n * e.g. '1-800-CALL-NUM' or 'CALL-NUM'\n * @param msisdn\n */\nexport const convertVanityNumber = (msisdn: string): string => {\n  return msisdn\n    .split('')\n    .map((char) => {\n      switch (char.toLowerCase()) {\n        case 'a':\n        case 'b':\n        case 'c':\n          char = '2'\n          break\n        case 'd':\n        case 'e':\n        case 'f':\n          char = '3'\n          break\n        case 'g':\n        case 'h':\n        case 'i':\n          char = '4'\n          break\n        case 'j':\n        case 'k':\n        case 'l':\n          char = '5'\n          break\n        case 'm':\n        case 'n':\n        case 'o':\n          char = '6'\n          break\n        case 'p':\n        case 'q':\n        case 'r':\n        case 's':\n          char = '7'\n          break\n        case 't':\n        case 'u':\n        case 'v':\n          char = '8'\n          break\n        case 'w':\n        case 'x':\n        case 'y':\n        case 'z':\n          char = '9'\n          break\n      }\n      return char\n    })\n    .join('')\n}\n\n/**\n *\n * @param did\n */\nexport const cleanDID = (did: string): string => {\n  if (!did) {\n    return ''\n  }\n  // remove everything that is not a number, a '+', comma, hashtag or astrix\n  return did.replace(/[^\\d\\+,#\\*]/g, '')\n}\n\n/**\n *\n * @param did\n */\nexport const pureDigitsDID = (did: string): string => {\n  if (!did) {\n    return ''\n  }\n\n  const cleanDid = cleanDID(did)\n\n  // remove everything that is not a number\n  return cleanDid.replace(/[^\\d]/g, '')\n}\n\n/**\n * find a line in a line array by line URI or Line\n *\n * @param {URI | Line} lineURI\n * @param {Line[]} lines\n */\nexport const findInLines = (lineURI: URI | Line, lines: Line[]): Line => {\n  return lineURI instanceof Line\n    ? lines.find((l) => l.uri === pureDigitsDID(lineURI.uri))\n    : lines.find((l) => l.uri === pureDigitsDID(lineURI))\n}\n\n/**\n *\n * @param uri\n */\nexport const stripPrefix = (uri: string): string => {\n  if (!uri) {\n    return uri\n  }\n  let did\n  if (/^((tel|ext|sip|mailto):)?[^a-z]*$/i.test(uri)) {\n    did = cleanDID(uri)\n  }\n  if (did || did === '') {\n    if (did.length === 11 && did.startsWith('1')) {\n      return did.slice(1)\n    } else if (did.length === 12 && did.startsWith('+1')) {\n      return did.slice(2)\n    }\n    return did\n  }\n  return uri.replace(/^(mailto|sip):/, '')\n}\n\n/**\n * Extracts and standardizes msisdn values.\n * Only handles a few embedded msisdn formats.\n * For other more complicated MSISDN extraction call 'parseMSISDN'\n * @param msisdn\n * @param addPlus\n * @returns formatted US (i.e. 12065551212) or international (i.e. +905343548812) MSISDN or empty string for bad input\n */\nexport const formatLineInfo = (msisdn: string, addPlus?: boolean): string => {\n  // first be sure the msisdn does not have a prefix like 'tel:'.  This will still leave a leading '+'\n  let strippedMsisdn = pureDigitsDID(stripPrefix(msisdn))\n  const matchesUS = strippedMsisdn.match(/^(\\+?1)?(\\d{10})$/)\n  let formattedMsidn = ''\n  if (matchesUS) {\n    // The raw result we want is usually in offset [2], but provide a backup of offset [0]\n    const matchData = matchesUS[2] || matchesUS[0]\n    // US 10 digit dialing: Always add the '1' country code and optionally add the '+'\n    if (addPlus) {\n      formattedMsidn = '+1' + matchData\n    } else {\n      formattedMsidn = '1' + matchData\n    }\n  } else {\n    if (strippedMsisdn.startsWith('011')) {\n      strippedMsisdn = strippedMsisdn.substr(3) // remove leading '011'\n    }\n    const matchesForeign = strippedMsisdn.match(/^(\\+?)?(\\d{11,15})$/)\n    if (matchesForeign) {\n      const matchData = matchesForeign[2] || matchesForeign[0]\n      formattedMsidn = '+' + matchData\n    } else {\n      // likely an extension or local 7 digit number without area code.\n      // Disallow more than 20 digits\n      formattedMsidn = pureDigitsDID(strippedMsisdn).substr(0, 20)\n    }\n  }\n\n  return formattedMsidn\n}\n\n/**\n * This parseMSISDN is from eDigits code.\n */\nexport const parseMSISDN = (msisdn: string): string => {\n  //Todo needs to be rewritten to be human readable\n  if (msisdn) {\n    // Extract the MSISDN from sip:MSISDN@domain\n    if (msisdn.match(/^sip:(\\+?\\d+)@.+;user=phone/)) {\n      msisdn = msisdn.match(/^sip:(\\+?\\d+)@.+;user=phone/)[1]\n    } else if (msisdn.match(/^sip:(\\+\\d{11})@.+/)) {\n      msisdn = msisdn.match(/^sip:(\\+\\d{11})@.+/)[1]\n    } else {\n      msisdn = stripPrefix(msisdn)\n    }\n    let testMsisdn = msisdn.replace(/[^\\d\\+,#\\*]/g, '')\n    const matchesUS = testMsisdn.match(/^(\\+?1)?(\\d{10})$/)\n    const matchesForeign = testMsisdn.match(/^(\\+?)?(\\d{11,15})$/)\n    if (matchesUS && matchesUS[2]) {\n      // US 10 digit dialing: add country code before dialing\n      // '+1 (206) 775-3445' with any combination of whitespace, hyphens, parentheses\n      msisdn = '+1' + matchesUS[2]\n    } else if (matchesForeign && matchesForeign[2]) {\n      msisdn = '+' + matchesForeign[2]\n    } else if (/[a-z]/i.test(msisdn) && msisdn.indexOf('@') === -1 && msisdn !== 'anonymous') {\n      // e.g. '1-800-CALL-NUM' or 'CALL-NUM' but explicity not an email address\n      const convertedMsisdn = convertVanityNumber(msisdn)\n      testMsisdn = parseMSISDN(convertedMsisdn)\n      if (testMsisdn.length > 0) {\n        msisdn = testMsisdn\n      }\n    } else if (/\\d/.test(msisdn) && /^[\\d\\-\\(\\)\\+#,\\s]+$/.test(msisdn)) {\n      msisdn = msisdn.replace(/[^\\d\\+,#]/g, '')\n    } else if (msisdn.startsWith('sip:') && msisdn.indexOf('@') !== -1) {\n      if (!msisdn.substring(4, msisdn.indexOf('@'))) {\n        // for number\n        msisdn = msisdn.substring(4, msisdn.indexOf('@'))\n      } else if (msisdn.includes('stgsip.t-mobile.com')) {\n        // for tuid\n        // ex: sip:U-edb6294e-6316-4496-9c2e-a9c1826bccdc@poims001.ucc1.ucc.stgsip.t-mobile.com\n        msisdn = msisdn.substring(4, msisdn.indexOf('@'))\n      } else {\n        msisdn = msisdn.replace('sip:', '')\n      }\n    } else if (msisdn.startsWith('uid:')) {\n      if (msisdn.match(/uid:(.*)@/).length === 2) {\n        const convertedMsisdn = msisdn.match(/uid:(.*)@/)[1]\n        // If it starts with a letter, than it's an email address,\n        // otherwise it's a number\n        if (convertedMsisdn.match(/^[A-Z]/i)) {\n          msisdn = msisdn.replace('uid:', '')\n        } else {\n          msisdn = convertedMsisdn\n        }\n      } else {\n        msisdn = msisdn.replace('uid:', '')\n      }\n    }\n\n    // This could be an extension or a number (eg: 1234@stg3.pool1.ucc.t-mobile.com)\n    const numMatch = msisdn.match(/(^[+]?[\\d]*)@.+/)\n    if (numMatch && numMatch.length === 2) {\n      msisdn = msisdn.match(/(^[+]?[\\d]*)@.+/)[1]\n    }\n    // else: unrecognized format: return input as given\n  } else {\n    // eslint-disable-next-line no-console\n    console.warn('parseMsisdn: input is not a string. MSISDN: ', msisdn)\n  }\n  return msisdn\n}\n\n/**\n * Create a Line object based on the passed URI\n * If the parameter is already a Line just returns it\n *\n * @param {string} uri\n * @returns {}\n */\nexport const toLine = (uri: URI | Line): Line => {\n  if (!uri) {\n    return undefined\n  }\n  if (uri instanceof Line) {\n    return uri\n  }\n\n  return new Line(lineTypeFromURI(uri), parseMSISDN(uri))\n}\n\n/**\n * Converts the passed arguments to a Line[]\n * Returns undefined if the argument is undefined or conversion is not possible\n *\n * @param { | []} uri\n * @returns {[]}\n */\nexport const toLines = (uri: URI | Line | URI[] | Line[]): Line[] => {\n  if (!uri) {\n    return undefined\n  }\n  if (uri instanceof Line) {\n    return [uri]\n  }\n  if (typeof uri === 'string') {\n    return [toLine(uri)]\n  }\n  if (uri.length === 0) {\n    return []\n  }\n  if (uri[0] instanceof Line) {\n    return uri as Line[]\n  } else if (Array.isArray(uri)) {\n    // assuming it's a URI[]\n    return (uri as URI[]).map(toLine)\n  }\n\n  return undefined\n}\n\n/**\n * Parse and extract / convert the participant address to an internal known format\n *\n * @param {string} participantAddress\n * @returns {string} raw msisdn for the participant. ex: 2065551234\n */\nexport const parseParticipantAddress = (participantAddress: string): string => {\n  if (!participantAddress) {\n    return participantAddress\n  }\n\n  // Several known possible formats for participantAddress\n  // \"+12069105100@msg.pc.t-mobile.com\"\n  // \"tel:+12069105100\"\n  // \"sip:+12065551234\"\n  // \"+12069105109;npdi;rn=+12063340081@msg.pc.t-mobile.com\"\n\n  // result: '12065551212'\n\n  // do the split('@') just in case the suffix is not from 't-mobile.com' and contains numbers\n  let nameBase = participantAddress.split('@')[0]\n  if (nameBase === 'sip:anonymous' || nameBase === 'anonymous') {\n    return 'anonymous'\n  }\n  // do the spit(';') in case call is from outside T-Mobile and has odd adjoined segments prior to the '@'\n  nameBase = nameBase.split(';')[0]\n  return formatLineInfo(pureDigitsDID(nameBase))\n}\n\n/**\n * Parse and extract the participant friendly name and uri\n * @param participantAddress\n * @returns {string}\n */\nexport const parseParticipantAndFriendlyName = (participantAddress: string): { name: string; uri: string } => {\n  if (!participantAddress) {\n    return { name: '', uri: '' }\n  }\n  // There are several types of participant address this handles\n  // \"sip:+12534577595@msg.pc.t-mobile.com\"\n  // or sometimes\n  // '\"John%20smith\" <sip:+12534577595@msg.pc.t-mobile.com>'\n  // However, there are all kinds inputs that don't follow this pattern.\n\n  let uri\n  const comps = participantAddress.split('<')\n  if (comps.length < 2) {\n    // simple case like: \"sip:+12534577595@msg.pc.t-mobile.com\"\n    uri = parseParticipantAddress(participantAddress)\n    return {\n      name: uri,\n      uri,\n    }\n  }\n\n  // fancy case like: '\"John%20smith\" <sip:+12534577595@msg.pc.t-mobile.com>'\n  uri = parseParticipantAddress(comps[1])\n\n  // remove embedded string quotation marks and extra white space\n  let name = comps[0].replace(/\\\"/g, '').trim()\n  try {\n    // Some names have encoded white space and some might have invalid URI format.\n    name = decodeURIComponent(name)\n  } catch (e) {\n    // console.warn(`Could not URI decode ${rawName}, ${e}, returning ${rawName}`);\n    // return rawName\n  }\n\n  return {\n    name: name.toLowerCase(), // Format name to all lower case for consistency\n    uri,\n  }\n}\n\n/**\n * Regexp to test email format\n * @param {string} test\n * @returns {boolean}\n */\nexport const isEmail = (test: string): boolean => !!test.match(/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}/)\n\n/**\n * Regexp to test phone number format\n * @param {string} test\n * @returns {boolean}\n */\nexport const isMSISDN = (test: string): boolean =>\n  !!test.match(/^[+]?[(]?[0-9]{3}[)]?[-\\s.]?[0-9]{3}[-\\s.]?[0-9]{4,6}$/)\n\n/**\n *\n * @param did\n */\nconst addCountryCode = (did: string): string => {\n  const splitDid = did.split(/[,#\\*]/, 1)\n  return splitDid[0].length === 10 ? `+1${did}` : did\n}\n\n/**\n *\n * @param srcUri\n * @param withCountryCode\n */\nexport const addPrefixForUri = (srcUri: string, withCountryCode?: boolean): string => {\n  if (!srcUri) {\n    return srcUri\n  }\n  const uri = stripPrefix(srcUri)\n  if (uri && uri.includes('@')) {\n    return `mailto:${uri}`\n  } else if (/^[^a-z]+$/.test(uri)) {\n    const did = cleanDID(uri)\n    if (did.length !== 0) {\n      if (did.length > 3 && did.length <= 6) {\n        // do not add ext:, required by Server side\n        return `ext:${did}`\n      } else {\n        let pn: string\n        if (withCountryCode) {\n          pn = addCountryCode(did)\n        } else {\n          pn = did\n        }\n        return `tel:${pn}`\n      }\n    }\n  }\n  return uri\n}\n\n/**\n *\n * @param {string} phoneNumber\n * @returns {boolean}\n */\nexport const isValidPhoneNumber = (phoneNumber: string): boolean => {\n  let isValid = false\n  if (phoneNumber) {\n    const value = phoneNumber.replace(/[\\s\\()\\-\\.]/g, '').replace(' ', '')\n    isValid = /^\\+?[0-9]{3,}[0-9,\\*#]*$/.test(value)\n  }\n  return isValid\n}\n\n/**\n *\n * @param {string} email\n */\nexport function isValidEmail(email: string): boolean {\n  return email ? /^[\\w-.]+@([\\w-]+\\.)+[\\w-]+$/.test(email.replace(/^\\s+|\\s+$/g, '')) : false\n}\n\n/**\n *\n * @param xmlData\n * @param jsonData\n * @param boundary\n * @param userId\n */\nexport function frameMultipartFormDataForECallAndChat(\n  xmlData: string,\n  jsonData: string,\n  boundary: string,\n  userId: string\n): string {\n  let multipart =\n    '--' +\n    boundary +\n    '\\r\\nContent-Disposition: form-data; name=root-fields' +\n    '\\r\\nContent-Type: application/json' +\n    '\\r\\nContent-Length: ' +\n    jsonData.length.toString() +\n    '\\r\\n\\r\\n' +\n    jsonData +\n    '\\r\\n\\r\\n'\n  multipart +=\n    '--' +\n    boundary +\n    '\\r\\nContent-Disposition: form-data; name=attachments' +\n    '\\r\\nContent-Type: application/pidf+xml' +\n    '\\r\\nContent-Length: ' +\n    xmlData.length.toString() +\n    '\\r\\nContent-ID: <' +\n    userId +\n    '> ' +\n    '\\r\\n\\r\\n' +\n    xmlData +\n    '\\r\\n\\r\\n'\n  multipart += '--' + boundary + '--'\n\n  return multipart\n}\n\n/**\n *\n * @param jsonData\n * @param filename\n * @param boundary\n * @param contentData\n * @param contentType\n */\nexport function frameMultipartFormDataForUploadFile(\n  jsonData: string,\n  filename: string,\n  boundary: string,\n  contentData: string,\n  contentType: string\n): string {\n  const boundary1 = secureMathRandom().toString().substring(2)\n  let multipart =\n    '--' +\n    boundary +\n    '\\r\\nContent-Disposition: form-data; name=root-fields' +\n    '\\r\\nContent-Type: application/json' +\n    '\\r\\nContent-Length: ' +\n    jsonData.length.toString() +\n    '\\r\\n\\r\\n' +\n    jsonData +\n    '\\r\\n\\r\\n'\n  multipart +=\n    '--' +\n    boundary +\n    '\\r\\nContent-Disposition: form-data; name=attachments' +\n    '\\r\\nContent-Type: multipart/mixed; boundary=\"' +\n    boundary1 +\n    '\"' +\n    '\\r\\n\\r\\n' +\n    '--' +\n    boundary1 +\n    '\\r\\nContent-Type: ' +\n    contentType +\n    '; name=\"' +\n    filename +\n    '\"' +\n    '\\r\\nContent-Disposition: attachment; filename=\"' +\n    filename +\n    '\"' +\n    '\\r\\nContent-Transfer-Encoding: base64' +\n    '\\r\\n\\r\\n' +\n    contentData +\n    '\\r\\n\\r\\n' +\n    '--' +\n    boundary1 +\n    '--' +\n    '\\r\\n' +\n    '--' +\n    boundary +\n    '--'\n\n  return multipart\n}\n", "/* eslint-disable no-console*/\n\n/**\n * Middleware Logger\n * General purpose, easy to use logger with remote logging abilities\n */\n\nexport enum LogLevel {\n  debug,\n  log,\n  info,\n  warn,\n  error,\n  fatal,\n}\n/**\n * LoggerConfig\n * Singleton to keep the enabled/disabled logging status all in one centralized place.\n */\nexport class LoggerConfig {\n  private static instance: LoggerConfig\n\n  private logLevel: LogLevel\n\n  // private remoteLoggingEnabled: boolean = false\n\n  // private constructor() {}\n\n  public static getInstance(): LoggerConfig {\n    if (!LoggerConfig.instance) {\n      LoggerConfig.instance = new LoggerConfig()\n    }\n    return LoggerConfig.instance\n  }\n\n  public setLogLevel = (level: LogLevel): void => {\n    this.logLevel = level\n  }\n\n  public getLogLevel = (): LogLevel => this.logLevel\n\n  // public enableRemoteLogging(remoteLogUrl: string, remoteLogToken: string) {\n  //   if (remoteLogUrl && remoteLogToken) {\n  //     this.remoteLoggingEnabled = true\n  //   } else {\n  //     console.error('Could not enable remote logging, missing url and/or token')\n  //   }\n  // }\n  //\n  // public disableRemoteLogging() {\n  //   // this.remoteLogger = undefined\n  //   this.remoteLoggingEnabled = false\n  // }\n\n  // public isRemoteLoggingEnabled = () => this.remoteLoggingEnabled\n}\n\n/**\n * General Purpose Logger Class\n * Supports log, info, debug, trace, warn, error, and fatal console log outputs\n * Prepends date-time and local label to each console output.\n * Can be individually enabled but typically reads from global logging configuration singleton\n */\nexport class Logger {\n  private readonly label: string\n\n  // private locallyEnabled: boolean = false\n\n  private configInst: LoggerConfig\n\n  constructor(label: string) {\n    this.label = label\n    this.configInst = LoggerConfig.getInstance()\n  }\n\n  // Log events to the console\n  public log = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.log) {\n      const dt = new Date().toISOString()\n      console.log(dt, this.label, ...args)\n    }\n  }\n\n  // Log events to the console and to remote logging service and console\n  public logRemote = (eventName: string, ...args: any[]): void => {\n    this.log(eventName, args)\n    // if (this.configInst.isRemoteLoggingEnabled()) {\n    // }\n  }\n\n  // Log fine-grained informational events useful for debugging.\n  public debug = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.debug) {\n      const dt = new Date().toISOString()\n      console.debug(dt, this.label, ...args)\n    }\n  }\n\n  // // Log debug events to remote logging service and console\n  // public debugRemote = (eventName: string, ...args: any[]): void => {\n  //   this.debug(args)\n  //   // if (this.configInst.isRemoteLoggingEnabled()) {\n  //   // }\n  // }\n\n  // Log informational messages that highlight the progress of the\n  // application at a coarse-grained level.\n  // Info messages correspond to normal application behavior and milestones.\n  public info = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.info) {\n      const dt = new Date().toISOString()\n      console.info(dt, this.label, ...args)\n    }\n  }\n\n  // // Log info to remote logging service and console\n  // public infoRemote = (eventName: string, ...args: any[]): void => {\n  //   this.info(args)\n  //   // if (this.configInst.isRemoteLoggingEnabled()) {\n  //   // }\n  // }\n\n  // Log potentially harmful events.\n  public warn = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.warn) {\n      const dt = new Date().toISOString()\n      console.warn(dt, this.label, ...args)\n    }\n    // if (this.configInst.isRemoteLoggingEnabled()) {\n    // }\n  }\n\n  // Log error events that might still allow the application to continue running.\n  public error = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.error) {\n      const dt = new Date().toISOString()\n      console.error(dt, this.label, ...args)\n    }\n    // if (this.configInst.isRemoteLoggingEnabled()) {\n    // }\n  }\n\n  // Log very severe error events that will presumably lead the application to crash.\n  public fatal = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.fatal) {\n      const dt = new Date().toISOString()\n      console.error(dt, 'FATAL:', this.label, ...args)\n    }\n    // if (this.configInst.isRemoteLoggingEnabled()) {\n    //\n    // }\n  }\n\n  // Log a stack trace\n  public trace = (...args: any[]): void => {\n    if (this.configInst.getLogLevel() <= LogLevel.debug) {\n      const dt = new Date().toISOString()\n      console.trace(dt, this.label, ...args)\n    }\n  }\n\n  // // Log a stack trace to remote logging service and console\n  // public traceRemote = (...args: any[]): void => {\n  //   this.trace(args)\n  //   if (this.configInst.isRemoteLoggingEnabled()) {\n  //     this.configInst.remoteLogger.sendInfo('trace', args)\n  //   }\n  // }\n\n  // public enableLocally = (state: boolean): void => {\n  //   this.locallyEnabled = state\n  // }\n}\n", "import { URI } from '../../common/api/commontypes'\nimport { Logger } from '../../common/libs/Logger'\nimport { isFunction, MapOf } from '../../common/libs/utils'\n\n/**\n * ToneHelper\n * Utility helper class for playing simple audio tone files\n */\nexport class ToneHelper {\n  public audioElements: MapOf<HTMLAudioElement> = {}\n\n  private logger: Logger\n\n  private okToPlay: boolean\n\n  constructor(logger: Logger) {\n    this.logger = logger\n  }\n\n  // we only use 'end' in startTone for dtmfs, only perform the end unmute if no other dtmf tones are playing.\n  private trueEnd = (end: () => void) => (): void => {\n    let doEnd = true\n    Object.keys(this.audioElements).forEach((el) => {\n      if (el.startsWith('dtmf-') && !this.audioElements[el].paused) {\n        doEnd = false\n      }\n    })\n    if (doEnd && isFunction(end)) {\n      end()\n    }\n  }\n\n  public startTone = (\n    toneKey: string,\n    toneURL: URI,\n    speakersDevice?: string,\n    volume: number = 0.5,\n    loop: boolean = true,\n    end?: () => void\n  ): Promise<void> => {\n    let audioElement = this.audioElements[toneKey]\n\n    if (audioElement && !audioElement.paused) {\n      return Promise.reject(`start ${toneKey}: audioElement already playing`)\n    }\n\n    if (!toneURL) {\n      return Promise.reject(`${toneKey} tone URL not specified`)\n    }\n\n    if (!audioElement) {\n      audioElement = this.audioElements[toneKey] = new Audio(toneURL)\n    }\n\n    audioElement.loop = loop\n    audioElement.muted = false\n    audioElement.volume = volume\n    audioElement.currentTime = 0\n\n    let promise = Promise.resolve()\n    if (speakersDevice) {\n      this.logger.log(`trying to use ringback Speakers: ${speakersDevice}`)\n\n      const setSinkId = (audioElement as any).setSinkId\n      if (isFunction(setSinkId)) {\n        promise = setSinkId(speakersDevice).catch((err: any) => {\n          this.logger.info('setSinkId rejected: ', speakersDevice, err)\n          // return Promise.reject('Cannot access indicated device')\n          return Promise.resolve() // will use default audio device\n        })\n      } else {\n        const errMsg = 'setSinkId not defined on audioElement'\n        this.logger.warn(errMsg)\n        // promise = Promise.reject(errMsg)\n      }\n    }\n\n    const play = (): Promise<void> => {\n      if (!this.okToPlay) {\n        return Promise.resolve()\n      }\n\n      this.logger.info(`Play ${toneURL}[${volume}] ${speakersDevice ? 'on ' + speakersDevice : ''}`)\n      if (end) {\n        audioElement.onended = this.trueEnd(end)\n        audioElement.onabort = this.trueEnd(end)\n        audioElement.onerror = this.trueEnd(end)\n      }\n      return audioElement.play()\n    }\n\n    this.okToPlay = true\n    return promise.then(() => play())\n  }\n\n  public stopTone = (toneKey: string): void => {\n    const audioElement = this.audioElements[toneKey]\n\n    if (audioElement && !audioElement.paused) {\n      audioElement.pause()\n      this.logger.log(`Paused ${toneKey} Audio Element`)\n    }\n    this.okToPlay = false\n  }\n}\n", "import { Call } from '../../code/calling/Call'\nimport { CallFilterConfig } from '../../api/CallManager'\nimport { noop } from '../../common/libs/utils'\n\n/**\n *\n * @param tone\n */\nexport const fileForTone = (tone: string): string => {\n  switch (tone) {\n    case '#':\n      return 'pound'\n    case '*':\n      return 'asterisk'\n    default:\n      return tone\n  }\n}\n\n/**\n * Data model for audio and video devices (mic/camera/speaker)\n */\nexport class Device {\n  public deviceId: string\n\n  public groupId: string\n\n  public label: string\n\n  public kind: MediaDeviceKind\n\n  constructor(json: MediaDeviceInfo | any) {\n    if (json) {\n      this.deviceId = json.deviceId\n      this.label = json.label\n      this.kind = json.kind\n      this.groupId = json.groupId\n    }\n  }\n\n  public toString(): string {\n    return this.kind + '->' + this.label + ' [' + this.deviceId + ']'\n  }\n}\n\n/**\n * CallFilter\n */\nexport class CallFilter {\n  private readonly cfg: CallFilterConfig\n\n  constructor(cfg: CallFilterConfig) {\n    noop()\n    this.cfg = cfg\n  }\n\n  public filter = (call: Call): boolean =>\n    this.cfg === undefined ||\n    ((!this.cfg.state || call.getState() === this.cfg.state) &&\n      (!this.cfg.direction || call.getDirection() === this.cfg.direction))\n\n  public static fromConfig = (cfgOrInstance: CallFilterConfig | CallFilter): CallFilter =>\n    cfgOrInstance instanceof CallFilter ? cfgOrInstance : new CallFilter(cfgOrInstance)\n}\n", "/**\n * Contains common definitions and interfaces for Calling\n */\n\n// import { ConferenceParticipant } from '../code/calling/DaasCallingAPIs'\nimport { Call } from '../code/calling/Call'\n\nexport declare type CallMediaType = 'audio' | 'video' | 'rtt'\n\nexport declare type CallMediaSide = 'LOCAL' | 'REMOTE'\n\nexport declare type CallDirection = 'incoming' | 'outgoing'\n\nexport interface CallMedia {\n  mediaType: CallMediaType\n  direction: CallDirection\n}\n\nexport const MAX_VOLUME = 100\nexport const MIN_VOLUME = 0\n\nexport declare type CallState =\n  | 'new'\n  | 'inprogress'\n  | 'failed'\n  | 'ringing'\n  | 'connected'\n  | 'held_locally'\n  | 'held_remotely'\n  | 'held_both'\n  | 'disconnected'\n  | 'ignore'\n  | 'videoUpgrade'\n  | 'merging'\n\nexport interface CallFlags {\n  emergency: boolean\n  conference: boolean\n}\n\nexport type CallEvents = 'got.inprogress'\n\nexport interface StreamsMap {\n  [key: string]: MediaStream\n}\n\nexport interface AudioDeviceIds {\n  microphoneDeviceId: string\n  speakersDeviceId: string\n}\n\n/**\n * Description of Audio Devices\n */\nexport interface AudioDeviceInfo {\n  groupId: string\n  label: string\n  isCurrentSelection: boolean\n}\n\n/**\n * @interface\n * Listener for Call events: connectivity, media, hold/un-hold\n */\nexport interface CallListener {\n  /**\n   * Fired when a call state is changed\n   *\n   * @param {Call} call\n   * @param {CallState} oldState\n   */\n  onCallStateChanged?(call: Call, oldState: CallState): void\n\n  /**\n   * Fired when a call transfer state succeeds or fails\n   *\n   * @param {Call} call\n   * @param {'fail' | 'ok'} newState\n   */\n  onTransferStatusChanged?(call: Call, newState: 'fail' | 'ok'): void\n\n  /**\n   * Fired when a call is transferred.  Shows new recipient.\n   * @param {Call} call\n   * @param {string} targetUri\n   * @param {string} targetName\n   */\n  onTransferDetails?(call: Call, targetUri: string, targetName: string): void\n\n  /**\n   * Fired when media is added to a call\n   *\n   * @param {Call} call\n   * @param {CallMedia} media\n   */\n  onMediaAdded?(call: Call, media: CallMedia): void\n\n  /**\n   * Fired when media is removed from a call\n   *\n   * @param {Call} call\n   * @param {CallMedia} media\n   */\n  onMediaRemoved?(call: Call, media: CallMedia): void\n\n  /**\n   * Fired when the local media stream is created or changes.\n   * Local audio is always rendered internally, but this stream\n   * can also be attached to an HTML video element to render video\n   *\n   * @param {Call} call\n   * @param {MediaStream} stream\n   * @param {hasVideo} boolean Indicates if video is included in the stream\n   */\n  onLocalStream?(call: Call, stream: MediaStream, hasVideo: boolean): void\n\n  /**\n   * Fired when remote media stream is created, altered, or destroyed.\n   * Remote audio is always rendered internally, but this stream\n   * can also be attached to an HTML video element to render video\n   *\n   * @param {Call} call\n   * @param {MediaStream} stream\n   * @param {hasVideo} boolean.  Indicates if video is included in the stream\n   */\n  onRemoteStream?(call: Call, stream: MediaStream, hasVideo: boolean): void\n\n  // /**\n  //  * Fired when the remote party requests to send video and the autoUpdate configuration is false\n  //  * @param call\n  //  */\n  // onVideoUpgradeRequested?(call: Call): void\n  //\n  // /**\n  //  * Fired when the status of one of the conference call participants changes,\n  //  * or a new participant is added.\n  //  * @param {Call} call\n  //  * @param participants\n  //  */\n  // // onConferenceParticipantUpdate?(call: Call, participants: ConferenceParticipant[]): void\n}\n", "/**\n * SimplePubSub\n * Supports very simple publish-subscribe operations\n */\n\nimport { Logger } from './Logger'\n\ninterface Subscriber {\n  identifier: string\n  callback: (...args: any) => void\n}\n\n// Have to ignore the <T> as TypeScript compiler thinks it is unused even though it is.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport class SimplePubSub<T> {\n  private subscriptionEvents: any = {}\n\n  private logger\n\n  /**\n   * constructor\n   * @param logger {Logger} Instance of logger to use for logging\n   */\n  public constructor(logger: Logger) {\n    this.logger = logger\n  }\n\n  /**\n   *\n   * @param eventName\n   * @param callback\n   * @param identifier\n   */\n  public subscribe = <T>(eventName: T, callback: (...args: any) => void, identifier: string): number => {\n    const eventNameStr = eventName.toString()\n    if (!eventNameStr) {\n      this.logger.warn('subscribe must include the event name parameter')\n      return -1\n    }\n\n    if (typeof callback !== 'function') {\n      this.logger.warn('subscribe event callback parameter must be a function')\n      return -2\n    }\n\n    if (!identifier) {\n      this.logger.warn('subscribe must include the event identifier parameter')\n      return -3\n    }\n\n    let subscriberList: [Subscriber] = this.subscriptionEvents[eventNameStr]\n    if (!subscriberList) {\n      this.subscriptionEvents[eventNameStr] = []\n      subscriberList = this.subscriptionEvents[eventNameStr]\n    }\n    // Make sure a subscriber cannot be already subscribed to this event\n    this.unsubscribe(eventName, identifier)\n    subscriberList.push({ callback, identifier })\n    return 0\n  }\n\n  /**\n   *\n   * @param eventName\n   * @param identifier\n   */\n  public unsubscribe = <T>(eventName: T, identifier: string): number => {\n    const eventNameStr = eventName.toString()\n    const subscriberList = this.subscriptionEvents[eventNameStr]\n    if (!subscriberList) {\n      return -1\n    }\n    const idx = subscriberList.findIndex((subscriber: Subscriber) => subscriber.identifier === identifier)\n    if (idx < 0) {\n      return -2\n    }\n    subscriberList.splice(idx, 1)\n    this.subscriptionEvents[eventNameStr] = subscriberList\n    return 0\n  }\n\n  /**\n   *\n   * @param eventName\n   * @param args\n   */\n  public publish = <T>(eventName: T, ...args: any): number => {\n    const eventNameStr = eventName.toString()\n    const subscriberList = this.subscriptionEvents[eventNameStr]\n    if (!subscriberList) {\n      // this.logger.warn('No Subscribers found for event: ', eventNameStr, ...args)\n      return -1\n    }\n    subscriberList.forEach((subscriber: Subscriber) => {\n      if (typeof subscriber.callback === 'function') {\n        window.setTimeout(() => subscriber.callback(...args), 0)\n      } else {\n        this.logger.warn(\n          'Subscriber callback is not a function.  eventName:',\n          eventNameStr,\n          'subscriber:',\n          subscriber.identifier\n        )\n      }\n    })\n    return 0\n  }\n}\n", "/**\n * WebRtcAPIs.ts\n * Created By Reid Heimbeck for T-Mobile, based on existing webrtc code.\n * Modernized for TypeScript and latest WebRtc apis.\n *\n * June 2020:\n * Basic Audio calling works.\n * Have not yet debugged Video and screen sharing.\n *\n */\n\nimport { makeApiError, extractErrorMessages, isFunction } from '../../common/libs/utils'\nimport { Logger } from '../../common/libs/Logger'\n\n///////////////////////////////////////////////////////////\n// This is a template of all the outside signalling methods\n// that must be defined and passed into this class\n// as a WebRtcSignaler object\n// This class is impervious to how the actual communication\n// to the outside world really happens.  It just\n// calls one of these 'Signaler' methods to invoke\n// some sort of signalling action\n///////////////////////////////////////////////////////////\nexport interface WebRtcSignaler {\n  // Local app signal notifications\n  onCallDowngradedToAudio(callId: string): void\n  onLocalStream(callId: string, stream: MediaStream, includesVideo: boolean): void // called when local stream created or changes\n  onReceivedCallEnded(callId: string): void\n  onReceivedCallFailed(callId: string, failureCode: number): void\n  onRemoteStream(callId: string, stream: MediaStream, includesVideo: boolean): void // called when receive remote stream or it changes\n}\n\nexport declare type ConnectionStatus = 'InProgress' | 'Proceeding' | 'Connected' | 'Hold' | 'Resume' | 'Disconnected'\nexport declare type ConnectionStatusCode = '180' | '183' | '200'\n\nexport type DeviceType = 'audioinput' | 'videoinput' | 'audiooutput'\n\nexport type MediaDirection = 'sendrecv' | 'sendonly' | 'recvonly' | 'inactive'\n\nexport class WebRtcAPIs {\n  // eslint-disable-next-line\n  private clientIP: string\n\n  private hasIncomingVideo: boolean = false\n\n  private hasOutgoingVideo: boolean = false\n\n  private incomingMediaStream: MediaStream\n\n  private invitationOfferSDP: string\n\n  private isCallTransfer: boolean = false\n\n  // eslint-disable-next-line\n  private isIPV6: boolean = false\n\n  private isMuted: boolean = false\n\n  private isOfferer: boolean = false\n\n  private isPaused: boolean = false\n\n  private hasGatheredSdp: boolean = false\n\n  private isSharing: boolean = false\n\n  private localCandidates: RTCIceCandidateInit[] = []\n\n  private localVideoCandidates: RTCIceCandidateInit[] = []\n\n  private logger: Logger\n\n  private onIceCandidateSdp: (sdp: string) => void\n\n  private outgoingMediaStream: MediaStream\n\n  private readonly callId: string\n\n  private readonly iceServers: RTCIceServer[]\n\n  private readonly peerConnection: RTCPeerConnection\n\n  private savedLocalDescription: RTCSessionDescriptionInit\n\n  private savedRemoteDescription: RTCSessionDescriptionInit\n\n  private signaler: WebRtcSignaler\n\n  private status: ConnectionStatus = 'Connected'\n\n  ////////////////////////////////////////////////\n  // Constructor\n  ///////////////////////////////////////////////\n  constructor(callId: string, signaler: WebRtcSignaler, turnServerIp: string, turnServerUdpPort: string) {\n    this.logger = new Logger('TMO-WEBRTC')\n    this.callId = callId\n    this.signaler = signaler\n\n    this.iceServers = [{ urls: [`stun:${turnServerIp}:${turnServerUdpPort}`] }]\n    this.peerConnection = new RTCPeerConnection({\n      bundlePolicy: 'balanced',\n      iceServers: this.iceServers,\n      rtcpMuxPolicy: 'require',\n    })\n\n    // Setup All PeerConnection Event Listeners\n    this.peerConnection.onconnectionstatechange = (event: any): void => {\n      this.onConnectionStateChange(event.target.connectionState)\n    }\n\n    this.peerConnection.onsignalingstatechange = (event: any): void => {\n      const localDirection = this.getCurrentLocalSdpDirection()\n      const remoteDirection = this.getCurrentRemoteSdpDirection()\n      this.logger.log(\n        'onSignalingStateChange event state: ',\n        event.target.signalingState,\n        ' localDir: ',\n        localDirection,\n        ' remoteDir: ',\n        remoteDirection\n      )\n      // No Event Handler\n    }\n\n    this.peerConnection.ontrack = (event: RTCTrackEvent): void => {\n      this.logger.log('onTrack event: ', event)\n      this.onTrackAdded(event)\n    }\n\n    // this.peerConnection['onaddstream'] = (event: Event): void => {\n    //   this.logger.log('legacy onAddStream event', event)\n    // }\n    //\n    // this.peerConnection['onremovestream'] = (event: Event): void => {\n    //   this.logger.log('legacy onRemoveStream event', event)\n    // }\n\n    this.peerConnection.onnegotiationneeded = (event: Event): void => {\n      this.logger.log('onNegotiationNeeded event state: ', event)\n      // No Event Handler\n    }\n\n    this.peerConnection.onicecandidate = (event: RTCPeerConnectionIceEvent): void => {\n      // Enable this logging statement only for debugging.  Too Chatty!\n      // this.logger.log('onicecandidate event: ', event.candidate)\n      this.onIceCandidate(event.candidate)\n    }\n\n    this.peerConnection.oniceconnectionstatechange = (event: any): void => {\n      this.logger.log('onIceConnectionStateChange event state: ', event.target.iceConnectionState)\n      // No Event Handler\n    }\n\n    this.peerConnection.onicegatheringstatechange = (event: any): void => {\n      this.logger.log('onIceGatheringStateChange event state: ', event.target.iceGatheringState)\n      // No Event Handler\n    }\n  }\n\n  /**\n   * initiateOfferProcess\n   * This method initiates the offer, which will kick-off the ICE candidate\n   * search if it has not yet done so.\n   * @param outgoingStream\n   * @returns Promise<void>\n   */\n  public initiateOfferProcess = async (outgoingStream?: MediaStream): Promise<string> => {\n    try {\n      if (outgoingStream) {\n        this.outgoingMediaStream = outgoingStream\n        this.setOutgoingTracksFromStream(outgoingStream, this.hasOutgoingVideo)\n        this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasOutgoingVideo)\n      }\n\n      this.isOfferer = true\n      const sessDescInit = await this.peerConnection.createOffer()\n      // const sessDescInit = await this.peerConnection.createOffer()\n      return await this.doSetLocalDescription(sessDescInit, true)\n    } catch (error) {\n      this.logger.error('initiateOfferProcess Error: ', extractErrorMessages(error))\n      return Promise.reject(error)\n    }\n  }\n\n  /**\n   * Allows for making a call using a specific device set (microphone and camera)\n   * @param deviceList\n   */\n  public createOfferWithDeviceList = async (deviceList: MediaDeviceInfo[]): Promise<string> => {\n    const stream = await this.getSelectedMediaStream(deviceList)\n    return await this.initiateOfferProcess(stream)\n  }\n\n  /**\n   * Accept the request for a new incoming call or modifications to the existing call\n   * such as to add or remove video\n   * @param deviceList list of media devices to use for this call.  Allows specifying camera, mic, and speakers\n   * @param acceptIncomingVideo: accept the incoming video if present (defaults to false)\n   * @param provideOutgoingVideo: Respond to this call with outgoing video\n   */\n  public acceptIncomingCallInvitation = (\n    deviceList: MediaDeviceInfo[],\n    acceptIncomingVideo: boolean = false,\n    provideOutgoingVideo: boolean = false\n  ): Promise<string> => {\n    try {\n      if (this.isCallTransfer) {\n        return this.createOfferWithDeviceList(deviceList)\n      } else {\n        const audioOnly = !acceptIncomingVideo\n        const addOutgoingVideo = provideOutgoingVideo && !audioOnly\n        this.status = 'Connected'\n        return this.createAnswerForAccept(this.invitationOfferSDP, deviceList, audioOnly, addOutgoingVideo)\n      }\n    } catch (error) {\n      this.logger.error('onIceCandidateCollectionComplete Error: ', extractErrorMessages(error))\n      this.closePeerConnections()\n      return Promise.reject(error)\n    }\n  }\n\n  /**\n   * Mute or unMute a call\n   * @param muteThisCall\n   * @returns {boolean} success\n   */\n  public toggleCallMute = (muteThisCall: boolean): boolean => {\n    // Presumes only one audio track\n    const sender = this.findSender('audio')\n    if (sender) {\n      sender.track.enabled = !muteThisCall\n      this.isMuted = muteThisCall\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Pause or unPause call video\n   * @param pauseVideo\n   */\n  public toggleCallVideoPaused = (pauseVideo: boolean): void => {\n    // presumes only one video track\n    const sender = this.findSender('video')\n    if (sender) {\n      sender.track.enabled = !pauseVideo\n    }\n    this.isPaused = pauseVideo\n  }\n\n  /**\n   *\n   */\n  public closePeerConnections = (): void => {\n    if (this.outgoingMediaStream) {\n      this.stopMedia(this.outgoingMediaStream)\n      this.outgoingMediaStream = undefined\n    }\n\n    if (this.incomingMediaStream) {\n      this.stopMedia(this.incomingMediaStream)\n      this.incomingMediaStream = undefined\n    }\n\n    if (this.peerConnection.signalingState !== 'closed') {\n      this.peerConnection.close()\n    }\n  }\n\n  /**\n   * Accessor to get the out-going Media stream\n   */\n  public getOutgoingMediaStream = (): MediaStream => {\n    return this.outgoingMediaStream\n  }\n\n  /**\n   * Accessor to get the in-coming media stream\n   */\n  public getIncomingMediaStream = (): MediaStream => {\n    return this.incomingMediaStream\n  }\n\n  /**\n   *\n   * @param sdp\n   * @param localOfferer: Is this client the offerer or the answerer for this sdp exchange?\n   */\n  public setRemoteSessionDescriptionFromSdp = async (sdp: string, localOfferer: boolean): Promise<void> => {\n    if (this.isCallStillActive()) {\n      this.isOfferer = localOfferer\n      const remoteSessionDesc = this.parseSdpForRemoteSessionDesc(sdp)\n      this.savedRemoteDescription = remoteSessionDesc\n      this.logger.log('setRemoteDescription: ', remoteSessionDesc.type, '\\n', remoteSessionDesc.sdp)\n      // this.logger.log('setRemoteDescription: ', remoteSessionDesc)\n      await this.peerConnection.setRemoteDescription(remoteSessionDesc).catch((error) => {\n        this.logger.error('Error Setting WebRTC Remote Description', error)\n        return Promise.reject(error)\n      })\n    } else {\n      return Promise.reject(makeApiError('Cannot complete this procedure. The peerConnection has closed', -1))\n    }\n  }\n\n  /**\n   * Gets the current Local Session Description\n   * @returns {string} the whole 'a-tag' record line current localDescription\n   */\n  public getCurrentLocalSdpDirection = (): string => {\n    const localDesc = this.peerConnection.localDescription\n    if (localDesc && localDesc.sdp) {\n      return this.getSdpDirection(localDesc.sdp)\n    }\n    return ''\n  }\n\n  /**\n   * Gets the current Remote Session Description\n   * @returns {string} the whole 'a-tag' record line current remoteDescription\n   */\n  public getCurrentRemoteSdpDirection = (): string => {\n    const remoteDesc = this.peerConnection.remoteDescription\n    if (remoteDesc && remoteDesc.sdp) {\n      return this.getSdpDirection(remoteDesc.sdp)\n    }\n    return ''\n  }\n\n  /**\n   * Respond to an offer to Hold\n   * @param sdp\n   */\n  public createAnswerForHold = async (sdp: string): Promise<string> => {\n    await this.setRemoteSessionDescriptionFromSdp(sdp, false)\n    const answerSessDesc = await this.peerConnection.createAnswer()\n    // answerSessDesc.sdp = this.processSDPForHoldAnswer(answerSessDesc.sdp)\n\n    return await this.doSetLocalDescription(answerSessDesc)\n  }\n\n  /**\n   * Respond to a remote offer to Resume from remoteHold\n   * @param {string} remoteSdp\n   * @param {boolean} isLocalHold - Is the client still in a local hold state as well\n   * @returns {string} localSdp\n   */\n  public createAnswerForResume = async (remoteSdp: string, isLocalHold: boolean): Promise<string> => {\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    const answerSessDesc = await this.peerConnection.createAnswer()\n\n    if (isLocalHold) {\n      answerSessDesc.sdp = this.processSDPForResumeAnswer(answerSessDesc.sdp, isLocalHold)\n    }\n\n    const localSdp = await this.doSetLocalDescription(answerSessDesc)\n\n    if (this.getSdpDirection(localSdp) === 'a=sendrecv') {\n      this.status = 'Resume'\n    } else {\n      this.status = 'Hold'\n    }\n    return localSdp\n  }\n\n  /**\n   * Create the Hold Offer\n   * @param forceInactive\n   * @returns {string} local SDP string\n   */\n  public createOfferForHold = async (forceInactive: boolean): Promise<string> => {\n    const previousSdpDirection = this.getSdpDirection(this.peerConnection.localDescription.sdp)\n    // this call to createOffer does not spawn an ICE Candidate negotiation\n    const localSessDesc = await this.peerConnection.createOffer()\n\n    localSessDesc.sdp = this.processSdpForHoldOffer(localSessDesc.sdp, previousSdpDirection, forceInactive)\n    return await this.doSetLocalDescription(localSessDesc)\n  }\n\n  /**\n   * Create the Resume Offer\n   * @returns {string} local SDP string\n   */\n  public createOfferForResume = async (isInRemoteHold: boolean): Promise<string> => {\n    // this call to createOffer does not spawn an ICE Candidate negotiation\n    const sessDescInit = await this.peerConnection.createOffer()\n\n    sessDescInit.sdp = this.processSdpForResumeOffer(sessDescInit.sdp, isInRemoteHold)\n    return await this.doSetLocalDescription(sessDescInit)\n  }\n\n  /**\n   * Respond to an offer for Transfer\n   * @param remoteSdp\n   * @returns localSdp\n   */\n  public createAnswerForTransfer = async (remoteSdp: string): Promise<string> => {\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    const sessDescInit = await this.peerConnection.createAnswer()\n    return await this.doSetLocalDescription(sessDescInit)\n  }\n\n  ///////////////////////////////////////////////\n  // Add our local video track to the outgoing media stream\n  private addOutgoingVideoTrack = async (deviceList: MediaDeviceInfo[]): Promise<void> => {\n    if (this.hasOutgoingVideo) {\n      return Promise.resolve()\n    }\n    this.hasOutgoingVideo = true\n    const stream = await this.getSelectedMediaStream(deviceList)\n    const videoTracks = stream.getVideoTracks()\n    if (videoTracks.length) {\n      const videoTrack = videoTracks[0]\n      this.outgoingMediaStream.addTrack(videoTrack)\n      this.setOutgoingTracksFromStream(this.outgoingMediaStream, true)\n      this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasOutgoingVideo)\n    } else {\n      this.hasOutgoingVideo = false\n      const camera = deviceList.find((device) => device.kind === 'videoinput')\n      const cameraLabel = camera ? camera.label : 'not specified'\n      return Promise.reject(`Could not create video track for camera: ${cameraLabel}`)\n    }\n  }\n\n  /**\n   * Tell other party we want to provide video data\n   * @param deviceList\n   */\n  public createOfferToAddVideo = async (deviceList: MediaDeviceInfo[]): Promise<string> => {\n    try {\n      await this.addOutgoingVideoTrack(deviceList)\n      return await this.initiateOfferProcess(this.outgoingMediaStream)\n    } catch (err) {\n      await this.removeOutgoingVideoTrack()\n      return Promise.reject(err)\n    }\n  }\n\n  /**\n   * Removes Video track from outgoing media stream\n   */\n  public removeOutgoingVideoTrack = async (): Promise<void> => {\n    if (!this.hasOutgoingVideo) {\n      return Promise.resolve()\n    }\n\n    this.hasOutgoingVideo = false\n    const videoTracks = this.outgoingMediaStream.getVideoTracks()\n    if (videoTracks.length) {\n      videoTracks.forEach((tr) => {\n        tr.stop()\n        tr.enabled = false\n        this.outgoingMediaStream.removeTrack(tr)\n      })\n    }\n\n    const videoSender = this.findSender('video')\n    if (videoSender) {\n      this.peerConnection.removeTrack(videoSender)\n    }\n    this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasOutgoingVideo)\n  }\n\n  /**\n   * Create offer to downgrade the call to audio, dropping all video.\n   * @param dropAllVideo: optional boolean, defaults to false.  If true, sends offer to drop\n   * video for both parties.\n   * @returns localSdp\n   */\n  public createOfferToRemoveVideo = async (dropAllVideo: boolean = false): Promise<string> => {\n    this.isOfferer = true\n    await this.removeOutgoingVideoTrack()\n\n    let sessDescInit = await this.peerConnection.createOffer()\n    if (dropAllVideo) {\n      sessDescInit = this.downgradeVideoPortSdi(sessDescInit)\n    }\n    return await this.doSetLocalDescription(sessDescInit, false)\n  }\n\n  /**\n   * Create an answer to the remote's instruction to downgrade the call to audio only\n   * @param remoteSdp\n   */\n  public createAnswerForDowngradeToAudio = async (remoteSdp: string): Promise<string> => {\n    this.hasIncomingVideo = false\n    if (this.hasOutgoingVideo) {\n      await this.removeOutgoingVideoTrack()\n    }\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    const sessDescInit = await this.peerConnection.createAnswer()\n    return await this.doSetLocalDescription(sessDescInit)\n  }\n\n  /**\n   * Create an Answer to acknowledge the remote side will stop sending their video\n   * @param remoteSdp\n   */\n  public createAnswerForDropVideo = async (remoteSdp: string): Promise<string> => {\n    this.hasIncomingVideo = false\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    const sessDescInit = await this.peerConnection.createAnswer()\n    return await this.doSetLocalDescription(sessDescInit)\n  }\n\n  /**\n   * Create an Answer to acknowledge the remote side has added video\n   * @param remoteSdp\n   */\n  public createAnswerForAddRemoteVideo = async (remoteSdp: string): Promise<string> => {\n    this.hasIncomingVideo = true\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    const sessDescInit = await this.peerConnection.createAnswer()\n    return await this.doSetLocalDescription(sessDescInit, true)\n  }\n\n  /**\n   * Create an Answer that rejects the remote side request to update video\n   * @param remoteSdp\n   */\n  public createAnswerToRejectRemoteVideoUpdate = async (remoteSdp: string): Promise<string> => {\n    this.hasIncomingVideo = false\n    this.hasOutgoingVideo = false\n    // This will currently kill all video.  Todo if there is currently out-going video,\n    // then set video direction to 'sendonly'\n    this.status = 'Connected'\n    remoteSdp = this.downgradeVideoPortSdp(remoteSdp)\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    const sessDescInit = await this.peerConnection.createAnswer()\n    return await this.doSetLocalDescription(sessDescInit, true)\n  }\n\n  /**\n   * Process the Answer response from the remote party provided in response to our\n   * request to add video\n   * @param sdp\n   * @returns Promise<boolean> true if remote party accepted the video upgrade\n   */\n  public processAnswerForRequestToAddVideo = async (sdp: string): Promise<boolean> => {\n    await this.setRemoteSessionDescriptionFromSdp(sdp, true)\n    this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasOutgoingVideo)\n    this.signaler.onRemoteStream(this.callId, this.incomingMediaStream, this.hasIncomingVideo)\n    return Promise.resolve(this.sdpEnabledForVideo(sdp))\n  }\n\n  /**\n   * Process the Answer response the other party gave us in return to our\n   * offer to drop our outgoing video data\n   * @param sdp\n   */\n  public processAnswerForDropVideo = async (sdp: string): Promise<void> => {\n    await this.setRemoteSessionDescriptionFromSdp(sdp, true)\n    this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasOutgoingVideo)\n    this.signaler.onRemoteStream(this.callId, this.incomingMediaStream, this.hasIncomingVideo)\n    this.status = 'Connected'\n  }\n\n  /**\n   * Processing an offer or answer for general call Progress statement\n   * @param remoteSdp\n   * @param weAreTheOfferer\n   * @returns localSdp\n   */\n  public processProgressSdp = async (remoteSdp: string, weAreTheOfferer: boolean): Promise<string> => {\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, weAreTheOfferer)\n    if (weAreTheOfferer) {\n      return this.peerConnection.localDescription.sdp\n    }\n\n    const sessDescInit = await this.peerConnection.createAnswer()\n    const newLocalSdp = await this.doSetLocalDescription(sessDescInit)\n\n    return newLocalSdp\n  }\n\n  /**\n   * An offer or answer was received that indicates a change to the current video states.\n   * Process the offer/answer and set the current video states accordingly\n   * @param remoteSdp\n   * @param isLocalOffer\n   * @returns new local sdp\n   */\n  public processVideoChangedSdp = async (\n    remoteSdp: string,\n    isLocalOffer: boolean,\n    remoteVideoDirection: string\n  ): Promise<string> => {\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, isLocalOffer)\n\n    const currentHasIncomingVideo = this.hasIncomingVideo\n    this.hasIncomingVideo = ['sendrecv', 'sendonly'].includes(remoteVideoDirection)\n    if (currentHasIncomingVideo !== this.hasIncomingVideo) {\n      this.signaler.onRemoteStream(this.callId, this.incomingMediaStream, this.hasIncomingVideo)\n    }\n\n    const canSendVideo = ['sendrecv', 'recvonly'].includes(remoteVideoDirection)\n    if (!canSendVideo && this.hasOutgoingVideo) {\n      await this.removeOutgoingVideoTrack()\n      this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasOutgoingVideo)\n    }\n\n    const sessDescInit = await this.peerConnection.createAnswer()\n    sessDescInit.sdp = this.setOutgoingVideoDirection(sessDescInit.sdp, remoteVideoDirection)\n    return await this.doSetLocalDescription(sessDescInit)\n  }\n\n  /**\n   * Stores the Offer SDP sent with the Call or other Invitation.\n   * They should not be processed in the webRTC remoteSession until after the user\n   * has accepted the invitation.\n   * @param sdp\n   */\n  public saveInvitationOfferSdp = (sdp: string): void => {\n    this.invitationOfferSDP = sdp\n  }\n\n  /**\n   *  Uses 'replaceTrack' method of updating the input source\n   *  rather than recreating and negotiating a whole new stream\n   *  Currently this presumes just one audio track\n   * @param newTrack\n   */\n  public replaceTrack = async (newTrack: MediaStreamTrack): Promise<void> => {\n    const foundSender = this.findSender(newTrack.kind)\n    if (foundSender) {\n      foundSender.track.enabled = false\n      await foundSender.replaceTrack(newTrack)\n      this.logger.log(`Replaced ${newTrack.kind} track`)\n    } else {\n      return Promise.reject(makeApiError('Cannot find sender', -3))\n    }\n  }\n\n  /**\n   * Stops both audio and video output streams\n   */\n  public holdOutgoingMedia = (): void => {\n    this.toggleCallMute(true)\n    this.toggleCallVideoPaused(true)\n  }\n\n  /**\n   * Resumes both audio and video output streams\n   */\n  public resumeOutgoingMedia = (): void => {\n    this.toggleCallMute(false)\n    this.toggleCallVideoPaused(false)\n  }\n\n  /**\n   * Indicates if the WebRtc call is still active\n   */\n  public isCallStillActive = (): boolean => {\n    return (\n      this.peerConnection.signalingState !== 'closed' &&\n      ['new', 'connecting', 'connected'].includes(this.peerConnection.connectionState)\n    )\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Public Accessor Methods\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  public getHasIncomingVideo = (): boolean => {\n    return this.hasIncomingVideo\n  }\n\n  public setHasIncomingVideo = (incomingVideo: boolean): void => {\n    // Only sets the flag.  Does not change the actual video\n    this.hasIncomingVideo = incomingVideo\n  }\n\n  public getHasOutgoingVideo = (): boolean => {\n    return this.hasOutgoingVideo\n  }\n\n  public setHasOutgoingVideo = (outgoingVideo: boolean): void => {\n    // Only sets the flag.  Does not change the actual video\n    this.hasOutgoingVideo = outgoingVideo\n  }\n\n  public getIsVideo = (): boolean => {\n    return this.hasIncomingVideo || this.hasOutgoingVideo\n  }\n\n  public setIsCallTransfer = (ict: boolean): void => {\n    this.isCallTransfer = ict\n  }\n\n  public getIsMuted = (): boolean => {\n    return this.isMuted\n  }\n\n  public setIsOfferer = (isOfferer: boolean): void => {\n    this.isOfferer = isOfferer\n  }\n\n  public getIsPaused = (): boolean => {\n    return this.isPaused\n  }\n\n  public getIsSharing = (): boolean => {\n    return this.isSharing\n  }\n\n  public setIsSharing = (isSharing: boolean): void => {\n    this.isSharing = isSharing\n  }\n\n  public getStatus = (): ConnectionStatus => {\n    return this.status\n  }\n\n  public setStatus = (newStatus: ConnectionStatus): void => {\n    this.status = newStatus\n  }\n\n  public getCurrentLocalDescription = (): RTCSessionDescription => {\n    return this.peerConnection.localDescription\n  }\n\n  public getCurrentRemoteDescription = (): RTCSessionDescription => {\n    return this.peerConnection.remoteDescription\n  }\n\n  public getPeerConnection = (): RTCPeerConnection => {\n    return this.peerConnection\n  }\n\n  public getStatsReport = (selector?: MediaStreamTrack): Promise<RTCStatsReport> => {\n    return this.peerConnection.getStats(selector)\n  }\n\n  /**\n   * Checks if peerConnection is in the process of negotiating a connection\n   * but the negotiation was not successful.  Rollback the peerConnection\n   * to its previous 'good' state.\n   *\n   * Negotiation errors can be common.  For instance, both parties initiate 'hold'\n   * would cause a negotiation conflict.\n   * We don't want to drop the call, so see if we can rollback to the previous\n   * state and start again later.\n   */\n  public resetSignalingState = async (resetState: ConnectionStatus): Promise<void> => {\n    const pc = this.getPeerConnection()\n    if (pc.signalingState !== 'closed' && pc.connectionState === 'connected') {\n      this.setStatus(resetState)\n      if (['Connected'].includes(resetState)) {\n        this.resumeOutgoingMedia()\n      } else if (['Hold'].includes(resetState)) {\n        this.holdOutgoingMedia()\n      }\n\n      const currentSignalingState = this.peerConnection.signalingState\n      if (currentSignalingState === 'have-local-offer') {\n        this.logger.log('Rolling-back Local Description to last known good:', this.savedLocalDescription)\n        // Tried using the 'rollback' descriptors but that doesn't enable two-way audio again\n        // So resetting localDescription to previous state.\n        return await pc\n          .setLocalDescription(this.savedLocalDescription)\n          .catch((err) => this.logger.error('resetSignalingState setLocalDescription', err))\n      } else if (currentSignalingState === 'have-remote-offer') {\n        this.logger.log('Rolling-back Remote Description to last known good: ', this.savedRemoteDescription)\n        return await pc\n          .setRemoteDescription(this.savedRemoteDescription)\n          .catch((err) => this.logger.error('resetSignalingState setRemoteDescription', err))\n      }\n    }\n\n    return Promise.resolve()\n  }\n\n  /**\n   * Sends a string of one or more DTMF codes\n   * @param dtmfCodes\n   * @param onToneChange callback handler called when tone playback completes.  Passes string to indicate which tone was just played\n   */\n  public sendDtmfCodes = (dtmfCodes: string, onToneChange?: (_tone: string) => void): boolean => {\n    const sender = this.findSender('audio')\n    if (!sender) {\n      this.logger.warn('No Sender Found for DTMF playback')\n      return false\n    }\n    const dtmf = sender.dtmf\n    const currentBuffer = dtmf.toneBuffer\n    let dtmfCodesToSend = dtmfCodes\n    if (currentBuffer) {\n      // If there are already tones in the buffer, read them out, cancel their play, and prepend them to the new tones\n      dtmf.insertDTMF('')\n      dtmfCodesToSend = currentBuffer + dtmfCodesToSend\n    }\n    if (isFunction(onToneChange)) {\n      dtmf.ontonechange = (evt: RTCDTMFToneChangeEvent): void => {\n        if (evt.tone) {\n          onToneChange(evt.tone)\n        }\n      }\n    }\n    // set the interToneGap to be slightly longer than the tone duration so the\n    // UI tone playback can finish before the next tone gets sent.\n    dtmf.insertDTMF(dtmfCodesToSend, 100, 120)\n    return true\n  }\n\n  /**\n   * Determines if the SDP has video enabled\n   * @param sdp\n   */\n  public sdpEnabledForVideo = (sdp: string): boolean => {\n    let status = false\n    const sdpComps = sdp.split('\\r\\n')\n    const vLine = sdpComps.find((line) => line.startsWith('m=video'))\n    if (vLine) {\n      const vLineComps = vLine.split(' ')\n      if (vLineComps[1] && vLineComps[1] !== '0') {\n        status = true\n      }\n    }\n    return status\n  }\n\n  /**\n   * Gets the current video media direction\n   */\n  public getCurrentVideoDirection = (): MediaDirection => {\n    const sdp = this.peerConnection.localDescription.sdp\n    return this.getSdpVideoDirection(sdp)\n  }\n\n  /**\n   * Gets the video media direction from the indicated sdp\n   * @param sdp\n   */\n  public getSdpVideoDirection = (sdp: string): MediaDirection => {\n    const sdpAudioVideoGroups = sdp.split('m=video')\n    if (sdpAudioVideoGroups.length > 1) {\n      const videoGroup = sdpAudioVideoGroups[1]\n      const res = this.parseSdpLinesForDirectionTag(videoGroup)\n      if (res.direction) {\n        return res.direction.replace('a=', '') as MediaDirection\n      }\n    }\n\n    return 'inactive'\n  }\n\n  /**\n   * Used for debugging WebRtc issues.  Prints to the console\n   * the 'interesting' elements of the WebRTC connection state.\n   */\n  public showStreamStatus = (detailed?: boolean): void => {\n    this.logger.log('ShowStreamStatus')\n\n    const localDesc = this.peerConnection.localDescription\n    const remoteDesc = this.peerConnection.remoteDescription\n    if (detailed) {\n      this.logger.log('LocalDescription:\\n', localDesc)\n      this.logger.log('RemoteDescription:\\n', remoteDesc)\n    }\n    this.logger.log('locale sdp direction: ', this.getSdpDirection(localDesc.sdp))\n    this.logger.log('remote sdp direction: ', this.getSdpDirection(remoteDesc.sdp))\n\n    if (this.incomingMediaStream) {\n      const audioTracks = this.incomingMediaStream.getAudioTracks()\n      if (!Array.isArray(audioTracks) || !audioTracks.length) {\n        this.logger.warn('no incoming audio tracks')\n      } else {\n        audioTracks.forEach((track) => {\n          if (detailed) {\n            this.logger.log('incoming Audio Track: ', track)\n            if (track.readyState !== 'live') {\n              this.logger.warn('Track Not Live')\n            }\n          } else {\n            this.logger.log(\n              'incoming audio track enabled: ',\n              track.enabled,\n              ' muted: ',\n              track.muted,\n              ' readyState: ',\n              track.readyState\n            )\n          }\n        })\n      }\n    } else {\n      this.logger.warn('No in-coming Media Stream defined')\n    }\n\n    if (this.outgoingMediaStream) {\n      const audioTracks = this.outgoingMediaStream.getAudioTracks()\n      if (!Array.isArray(audioTracks) || !audioTracks.length) {\n        this.logger.warn('no outgoing audio tracks')\n      } else {\n        audioTracks.forEach((track) => {\n          if (detailed) {\n            this.logger.log('outgoing Audio Track: ', track)\n            if (track.readyState !== 'live') {\n              this.logger.warn('Track Not Live')\n            }\n          } else {\n            this.logger.log(\n              'outgoing audio track enabled: ',\n              track.enabled,\n              ' muted: ',\n              track.muted,\n              ' readyState: ',\n              track.readyState\n            )\n          }\n        })\n      }\n    }\n\n    if (this.peerConnection) {\n      const sender = this.findSender('audio')\n      const receiver = this.findReceiver('audio')\n      if (detailed) {\n        this.logger.log('Audio Sender: ', sender)\n        this.logger.log('Audio Receiver: ', receiver)\n      } else {\n        this.logger.log('Audio Sender Track enabled: ', sender?.track?.enabled)\n        this.logger.log('Audio Receiver Track enabled: ', receiver?.track?.enabled)\n      }\n\n      let firstBytesReceived: string\n      let firstBytesSent: string\n      let secondBytesReceived: string\n      let secondBytesSent: string\n\n      this.peerConnection\n        .getStats()\n        .then((stats) => {\n          this.logger.log('WebRTC Stats:')\n          stats.forEach((stat) => {\n            if (detailed) {\n              if (\n                ['candidate-pair', 'inbound-rtp', 'media-source', 'outbound-rtp', 'track', 'transport'].includes(\n                  stat.type\n                )\n              ) {\n                this.logger.log(stat, '\\n')\n              }\n            } else {\n              if (['transport'].includes(stat.type)) {\n                firstBytesReceived = stat.bytesReceived\n                firstBytesSent = stat.bytesSent\n              }\n            }\n          })\n        })\n        .catch((error) => this.logger.warn('PeerConnection Stats error: ', error))\n\n      if (!detailed) {\n        window.setTimeout(() => {\n          this.peerConnection\n            .getStats()\n            .then((stats) => {\n              stats.forEach((stat) => {\n                if (['transport'].includes(stat.type)) {\n                  secondBytesReceived = stat.bytesReceived\n                  secondBytesSent = stat.bytesSent\n                }\n              })\n              this.logger.log('Sending Data: ', firstBytesSent && secondBytesSent && secondBytesSent > firstBytesSent)\n              this.logger.log(\n                'Receiving Data: ',\n                firstBytesReceived && secondBytesReceived && secondBytesReceived > firstBytesReceived\n              )\n            })\n            .catch((error) => this.logger.warn('PeerConnection Stats error: ', error))\n        }, 1000)\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Private Worker methods below here\n  /////////////////////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////\n  // Gather ICE Candidates\n  // Once we have found the SRFLX candidate, proceed with making or answering the call\n  private onIceCandidate = (candidate: RTCIceCandidateInit): void => {\n    let proceed\n\n    if (candidate) {\n      if (candidate.sdpMLineIndex === 0) {\n        this.localCandidates.push(candidate)\n      } else if (candidate.sdpMLineIndex === 1) {\n        this.localVideoCandidates.push(candidate)\n      }\n      this.logger.log('onIceCandidate: ', candidate.candidate)\n      const candidateComps = this.isSrflxCandidate(candidate)\n      proceed = candidateComps.isSrflx\n      if (candidateComps.isSrflx) {\n        this.clientIP = candidateComps.address\n        this.isIPV6 = candidateComps.isIPV6\n        this.logger.log('clientIP:', this.clientIP, ' isIPV6:', this.isIPV6)\n      }\n    } else {\n      // A null candidate indicates the completion of the candidate gathering\n      // Waiting for this occurrence will cause a long delay until the call starts.\n      // best to proceed when the srflx candidate has been identified\n      proceed = true\n    }\n\n    if (proceed && !this.hasGatheredSdp) {\n      this.hasGatheredSdp = true\n      const localDesc = this.peerConnection.localDescription\n      const localSdp = this.fixIPAddresses(this.doStandardSdpPrep(localDesc.sdp))\n      this.logger.log('onIceCandidateCollectionComplete')\n      this.logger.log('Initial clientIP: ', this.clientIP)\n      this.logger.log('LocalDescription being sent: ', localDesc.type, '\\n', localSdp)\n      if (isFunction(this.onIceCandidateSdp)) {\n        this.onIceCandidateSdp(localSdp)\n      } else {\n        this.logger.warn('ICE collection Occurred with no results collected')\n      }\n    }\n  }\n\n  ////////////////////////////////\n  private onTrackAdded = (event: RTCTrackEvent): void => {\n    this.logger.log('onTrackAdded Event: ', event)\n    if (!event.streams.length) {\n      this.logger.error('onTrack event has no streams', event)\n      return\n    }\n    if (event.streams.length > 1) {\n      this.logger.warn('onTrack event has multiple streams. ', event.streams)\n    }\n    this.incomingMediaStream = event.streams[0] // Presume always just one stream\n    const videoTracks = this.incomingMediaStream.getVideoTracks()\n    this.hasIncomingVideo = videoTracks.length > 0\n    this.signaler.onRemoteStream(this.callId, this.incomingMediaStream, this.hasIncomingVideo)\n  }\n\n  ////////////////////////////////\n  private onConnectionStateChange = (newConnectionState: RTCPeerConnectionState): void => {\n    this.logger.log('RTCPeerConnectionState Changed event. new state:', newConnectionState)\n    // Some RTCPeerConnection state changes would indicate a condition for the active call.\n    switch (newConnectionState) {\n      case 'closed':\n        // The connection has been closed\n        this.logger.log('WebRTC indicated call ended')\n        this.signaler.onReceivedCallEnded(this.callId)\n        break\n      case 'disconnected':\n        this.logger.log('WebRTC indicated call disconnected')\n        this.signaler.onReceivedCallEnded(this.callId)\n        break\n      case 'failed':\n        // One or more transports has terminated unexpectedly or in an error\n        this.logger.warn('WebRTC indicated call failure')\n        this.signaler.onReceivedCallFailed(this.callId, -1)\n        break\n    }\n  }\n\n  /////////////////////////////////\n  // Accepts an Audio or Video call, and possibly adds outgoing video\n  private createAnswerForAccept = async (\n    remoteSdp: string,\n    deviceList: MediaDeviceInfo[],\n    audioOnly: boolean,\n    addOutgoingVideo: boolean = false\n  ): Promise<string> => {\n    this.hasOutgoingVideo = addOutgoingVideo && !audioOnly\n    const stream = await this.getSelectedMediaStream(deviceList)\n    this.setOutgoingTracksFromStream(stream)\n    this.outgoingMediaStream = stream\n    this.signaler.onLocalStream(this.callId, this.outgoingMediaStream, this.hasIncomingVideo)\n\n    if (audioOnly) {\n      remoteSdp = this.downgradeVideoPortSdp(remoteSdp)\n    }\n\n    await this.setRemoteSessionDescriptionFromSdp(remoteSdp, false)\n    let sessDescInit = await this.peerConnection.createAnswer()\n    if (audioOnly) {\n      sessDescInit = this.downgradeVideoPortSdi(sessDescInit)\n    }\n    sessDescInit = this.setIceUfragAndIcePwd(sessDescInit)\n    return await this.doSetLocalDescription(sessDescInit, true)\n  }\n\n  /////////////////////\n  private setOutgoingTracksFromStream = (stream: MediaStream, addVideo: boolean = false): void => {\n    const audioTracks = stream.getAudioTracks()\n    const videoTracks = stream.getVideoTracks()\n\n    if (audioTracks && audioTracks.length) {\n      this.logger.log('setOutgoingTracksFromStream: Audio Tracks: ', audioTracks)\n      const newAudioTrack = audioTracks[0] // presume just 1 audio track\n      let trackAlreadyPresent = false\n      // remove existing audio track if it is different\n      const audioSender = this.findSender('audio')\n      if (audioSender) {\n        if (audioSender.track?.id !== newAudioTrack.id) {\n          this.peerConnection.removeTrack(audioSender)\n        } else {\n          trackAlreadyPresent = true\n        }\n      }\n      if (!trackAlreadyPresent) {\n        newAudioTrack.enabled = !this.isMuted\n        this.peerConnection.addTrack(newAudioTrack, stream)\n        this.logger.log('setOutgoingTracksFromStream: added Audio Track: ', newAudioTrack)\n      }\n    } else {\n      this.logger.warn('setOutgoingTracksFromStream: No Audio Tracks Found')\n    }\n\n    const videoSender = this.findSender('video')\n    if (addVideo && videoTracks?.length) {\n      const newVideoTrack = videoTracks[0] // presume just 1 video track\n      // remove existing video track if it is not the same as the new one\n      let trackAlreadyPresent = false\n      if (videoSender) {\n        if (videoSender.track?.id !== videoTracks[0].id) {\n          this.peerConnection.removeTrack(videoSender)\n        } else {\n          trackAlreadyPresent = true\n        }\n      }\n\n      if (!trackAlreadyPresent) {\n        newVideoTrack.enabled = true\n        this.peerConnection.addTrack(newVideoTrack, stream)\n        this.logger.log('setOutgoingTracksFromStream: added Video Track: ', newVideoTrack)\n      }\n    } else {\n      if (videoSender) {\n        this.peerConnection.removeTrack(videoSender)\n      }\n      this.logger.log('setOutgoingTracksFromStream: No Video Tracks Found')\n    }\n  }\n\n  /////////////////////////////////\n  // Consolidates a repeating code pattern used in creating SDP for Offers and Answers\n  private doStandardSdpPrep = (origSdp: string): string => {\n    let newSdp = this.setMediaBitrate(origSdp)\n    newSdp = this.removeUnsupportedAttrs(newSdp)\n    return this.enableVBRForOpusCodec(newSdp)\n  }\n\n  /////////////////////////////////\n  // Consolidates a repeating code pattern used to configure the WebRTC peer localDescription\n  // @param {RTCSessionDescriptionInit}\n  // returns {string} localSdp\n  private doSetLocalDescription = async (\n    sessionDesc: RTCSessionDescriptionInit,\n    waitForIceGathering: boolean = false\n  ): Promise<string> => {\n    // There are several articles stating that 'Munging' the sdp before calling setLocalDescription\n    // is not a good idea and may generate an error.  Still, it seems to work, and it seems\n    // that the localDescription would want to have the actual sdp that we're going to send\n    // to the remote.\n    sessionDesc.sdp = this.doStandardSdpPrep(sessionDesc.sdp)\n    this.savedLocalDescription = this.peerConnection.localDescription\n    this.logger.log('setLocalDescription: ', sessionDesc.type, '\\n', sessionDesc.sdp)\n\n    let waitingPromise = Promise.resolve('')\n\n    if (waitForIceGathering) {\n      this.hasGatheredSdp = false\n      // Setup for a callback for when ICE Negotiation completes\n      waitingPromise = new Promise((resolve) => {\n        const maxWaitTimer = window.setTimeout(() => {\n          this.onIceCandidateSdp = undefined\n          this.logger.warn('Time-out waiting for ICE candidate. Using localDescription sdp')\n          resolve(this.fixIPAddresses(this.peerConnection.localDescription.sdp))\n        }, 10_000) // wait 10 seconds max for ICE negotiation to complete before using default\n        this.onIceCandidateSdp = (sdp): void => {\n          window.clearTimeout(maxWaitTimer)\n          resolve(sdp)\n          this.onIceCandidateSdp = undefined\n        }\n      })\n    }\n\n    this.logger.log('doSetLocalDescription - calling setLocalDescription')\n    await this.peerConnection.setLocalDescription(sessionDesc).catch((error) => {\n      this.logger.error('Error Setting WebRTC Local Description', error)\n      return Promise.reject(error)\n    })\n\n    if (!waitForIceGathering) {\n      return this.fixIPAddresses(this.peerConnection.localDescription.sdp)\n    }\n    return waitingPromise\n  }\n\n  /////////////////////////\n  private setMediaBitrate = (sdp: string): string => {\n    const audioBitrate = 80 // kbps\n    const sdpInputLines = sdp.split('\\r\\n')\n    const sdpOutputLines: string[] = []\n    for (const line of sdpInputLines) {\n      // Don't copy the existing 'b=AS:' lines\n      // Copy over everything else\n      if (line.indexOf('b=AS:') < 0) {\n        sdpOutputLines.push(line)\n      }\n      if (line.includes('m=audio')) {\n        sdpOutputLines.push(`b=AS:${audioBitrate}`)\n        // sdpOutputLines.push('b=RS:800')\n        // sdpOutputLines.push('b=RS:2400')\n      }\n\n      if (line.includes('m=video')) {\n        sdpOutputLines.push('b=AS:512\\r\\na=framerate:20\\r\\na=framesize:100 480-640')\n      }\n    }\n\n    return sdpOutputLines.join('\\r\\n')\n  }\n\n  //////////////////////\n  private enableVBRForOpusCodec = (sdp: string): string => {\n    const cbr = 0 // cbr=0 : Variable Bit Rate encoding for call audio\n    const maxAverageBitrate = 24 * 1024\n    const mInpTime = 20\n    const useInBandFec = 0\n\n    const sdpLines = sdp.split('\\r\\n')\n    const opusIndex = this.findLine(sdpLines, 'a=rtpmap', 'opus/48000')\n    let opusPayload\n    if (opusIndex) {\n      opusPayload = this.getCodecPayloadType(sdpLines[opusIndex])\n    }\n    if (!opusPayload) {\n      return sdp\n    }\n\n    const fmtpLineIndex = this.findLine(sdpLines, `a=fmtp:${opusPayload}`)\n    if (!fmtpLineIndex) {\n      return sdp\n    }\n\n    sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex]\n      .split(' ')[0]\n      .concat(` minptime=${mInpTime};useinbandfec=${useInBandFec};cbr=${cbr};maxaveragebitrate=${maxAverageBitrate}`)\n\n    sdp = sdpLines.join('\\r\\n')\n    return sdp\n  }\n\n  /////////////////////////////////////////////\n  private removeUnsupportedAttrs = (sdp: string): string => {\n    // replace trickle-ICE with ICE-lite\n    const modSdp = sdp.replace('a=ice-options:trickle', 'a=ice-lite')\n    // Remove any attribute lines that have this form: a=fmtp:97 111/111.  Can appear with different number than 97\n    // These attributes were added to the SDP by Chromium 96, but cause an exception in WebRTC\n    // when applied to the RemoteDescription\n    return modSdp\n      .split('\\r\\n')\n      .filter((line) => !(line.includes('a=fmtp:') && line.includes('111/111')))\n      .join('\\r\\n')\n  }\n\n  /////////////////////////////////////////////\n  // If the current SDP already has a chosen IP in the c-line,\n  // then use that IP to fix the other missing IP addresses in the SDP\n  private fixIPAddresses = (sdp: string): string => {\n    if (this.clientIP) {\n      return this.setIPAddresses(sdp, this.clientIP)\n    }\n    const sdpLines = sdp.split('\\r\\n')\n    const cLine = sdpLines.find((line) => line.startsWith('c=IN IP'))\n    if (cLine) {\n      // IP address will be the third element in the c-line of the sdp\n      const cLineIp = cLine.split(' ')[2]\n      if (cLineIp !== '0.0.0.0') {\n        this.clientIP = cLineIp\n        sdp = this.setIPAddresses(sdp, this.clientIP)\n      }\n    }\n    return sdp\n  }\n\n  /////////////////////////////////////////////\n  private getCodecPayloadType = (sdpLine: string): string => {\n    const pattern = new RegExp('a=rtpmap:(\\\\d+) \\\\w+\\\\/\\\\d+')\n    const result = sdpLine.match(pattern)\n    return result && result.length === 2 ? result[1] : undefined\n  }\n\n  /////////////////////////////////////////////\n  private getMediaStreamPerDevices = (fullDeviceList: MediaDeviceInfo[]): Promise<MediaStream> => {\n    let deviceList: MediaDeviceInfo[] = fullDeviceList\n    if (!this.hasOutgoingVideo) {\n      deviceList = deviceList.filter((dl) => dl.kind !== 'videoinput')\n    }\n\n    const constraints: any = {}\n    for (const device of deviceList) {\n      if (device.kind === 'audioinput' && device.deviceId) {\n        constraints.audio = {\n          deviceId: device.deviceId,\n        }\n      } else if (this.hasOutgoingVideo) {\n        // Sometimes the video device does not show a deviceId\n        if (device.kind === 'videoinput') {\n          if (device.deviceId) {\n            constraints.video = {\n              deviceId: device.deviceId,\n            }\n          } else {\n            constraints.video = true\n          }\n        }\n      }\n    }\n    return navigator.mediaDevices.getUserMedia(constraints)\n  }\n\n  /////////////////////////////////////////////\n  private getSelectedMediaStream = async (devices?: MediaDeviceInfo[]): Promise<MediaStream> => {\n    this.logger.log('getSelectedMediaStream called.  Devices: ', devices)\n\n    if (devices) {\n      // Get a mediaStream for a specific set of devices (mic and camera)\n      const mediaStream = await this.getMediaStreamPerDevices(devices)\n      this.logger.log('getSelectedMediaStream devices, stream: ', devices, mediaStream)\n      return mediaStream\n    } else {\n      // Get a mediaStream for general constraints (audio and/or video, using the current default devices)\n      const constraints: MediaStreamConstraints = {\n        audio: true,\n        video: this.hasOutgoingVideo,\n      }\n      const mediaStream = await navigator.mediaDevices.getUserMedia(constraints)\n      this.logger.log('getSelectedMediaStream constraints, stream: ', constraints, mediaStream)\n      return mediaStream\n    }\n  }\n\n  //////////////////////////////////////////////\n  private findSender = (streamKind: string): RTCRtpSender => {\n    // Currently this method Presumes just one audio track per stream\n    const senders = this.peerConnection.getSenders()\n    return senders.find((sender) => sender.track && sender.track.kind === streamKind)\n  }\n\n  //////////////////////////////////////////////\n  private findReceiver = (streamKind: string): RTCRtpReceiver => {\n    // Currently this method Presumes just one audio track per stream\n    const receivers = this.peerConnection.getReceivers()\n    return receivers.find((sender) => sender.track && sender.track.kind === streamKind)\n  }\n\n  /////////////////////////////////////////////\n  private findLine = (sdpLines: string[], prefix: string, substr?: string): number => {\n    return this.findLineInRange(sdpLines, 0, -1, prefix, substr)\n  }\n\n  /////////////////////////////////////////////\n  private findLineInRange = (\n    sdpLines: string[],\n    startLine: number,\n    endLine: number,\n    prefix: string,\n    substr: string\n  ): number => {\n    const realEndLine = endLine !== -1 ? endLine : sdpLines.length\n    if (substr) {\n      substr = substr.toLowerCase()\n    }\n    for (let i = startLine; i < realEndLine; ++i) {\n      if (sdpLines[i].indexOf(prefix) === 0) {\n        if (!substr || sdpLines[i].toLowerCase().indexOf(substr) !== -1) {\n          return i\n        }\n      }\n    }\n    return undefined\n  }\n\n  /////////////////////////////////////////////\n  private stopMedia = (stream: MediaStream, tracks?: MediaStreamTrack[]): void => {\n    if (tracks) {\n      tracks.forEach((track) => track.stop())\n    }\n\n    if (stream) {\n      const tracks = stream.getTracks()\n      tracks.forEach((track) => track.stop())\n    }\n  }\n\n  /////////////////////////////////////////////\n  // Keep commented code block for possible later use.\n  // private parseSharingSDP(sdp: string): string {\n  //   const sdpLines = sdp.split('m=video')\n  //   for (const line of sdpLines) {\n  //     if (line.includes('UDP/TLS/RTP/SAVP 117')) {\n  //       return `m=video${line}`\n  //     }\n  //   }\n  //   return sdp\n  // }\n\n  /////////////////////////////////////////////\n  private getSdpDirection = (sdp: string): string => {\n    const parsedSdp = this.parseSdpLinesForDirectionTag(sdp)\n    if (parsedSdp.index > -1) {\n      return parsedSdp.direction\n    }\n    // default return value\n    return 'a=sendrecv'\n  }\n\n  /////////////////////////////////////////////\n  // Set the m=video line in the SessionDescription sdp, to disable video\n  private downgradeVideoPortSdi = (sdi: RTCSessionDescriptionInit): RTCSessionDescriptionInit => {\n    sdi.sdp = this.downgradeVideoPortSdp(sdi.sdp)\n    return sdi\n  }\n\n  //////////////////////////////////////////////\n  // Disable video in the SDP\n  // Find and Replace the current port value in that line with '0'\n  private downgradeVideoPortSdp = (sdp: string): string => {\n    const sdpArray = sdp.split('\\r\\n')\n    const currentVideoLine = sdpArray.find((line) => line.includes('m=video'))\n    if (currentVideoLine) {\n      // Replace  \"m=video {port number} ...\" with \"m=video 0 ...\n      const mVideoComps = currentVideoLine.split(' ')\n      mVideoComps[1] = '0'\n      const newVideoLine = mVideoComps.join(' ')\n      sdp = sdp.replace(currentVideoLine, newVideoLine)\n    }\n    return sdp\n  }\n\n  /////////////////////////////////////////////\n  private setIceUfragAndIcePwd = (sessionDescription: RTCSessionDescriptionInit): RTCSessionDescriptionInit => {\n    let iceUfrag = ''\n    let icePwd = ''\n    let sdp = sessionDescription.sdp\n    const sdpArray = sdp.split('\\r\\n')\n    for (const sdpItem of sdpArray) {\n      if (sdpItem.includes('a=ice-ufrag')) {\n        iceUfrag = sdpItem\n      }\n      if (sdpItem.includes('a=ice-pwd')) {\n        icePwd = sdpItem\n      }\n    }\n\n    sdp += iceUfrag + '\\r\\n'\n    sdp += icePwd + '\\r\\n'\n    sessionDescription.sdp = sdp\n    return sessionDescription\n  }\n\n  /////////////////////////////////////////////\n  // Set the 'a-tag' state for local offer to go on hold.\n  // Adjust for conditions of previously being on hold already, or needing to go directly\n  // to full 'inactive' mode\n  private processSdpForHoldOffer = (\n    localSdp: string,\n    previousSdpDirection: string,\n    forceInactiveState: boolean\n  ): string => {\n    const parsedSdp = this.parseSdpLinesForDirectionTag(localSdp)\n    if (parsedSdp.index > -1) {\n      if (\n        forceInactiveState ||\n        ['a=recvonly', 'a=inactive'].includes(previousSdpDirection) ||\n        parsedSdp.direction === 'a=recvonly'\n      ) {\n        // if 'forceInactiveState' is true, or\n        // if previously the local direction was already 'recvonly' or 'inactive'\n        // and this is another hold request in addition to the previous,\n        // then go to 'inactive'\n        parsedSdp.sdpParts[parsedSdp.index] = 'a=inactive'\n      } else {\n        // Else - normal case for local direction going on hold\n        parsedSdp.sdpParts[parsedSdp.index] = 'a=sendonly'\n      }\n    }\n    return parsedSdp.sdpParts.join('\\r\\n')\n  }\n\n  /////////////////////////////////////////////\n  // Local party wants to resume from hold. Need to adjust if remote party is in hold\n  private processSdpForResumeOffer = (localSdp: string, isInRemoteHold: boolean): string => {\n    const parsedSdp = this.parseSdpLinesForDirectionTag(localSdp)\n    if (parsedSdp.index > -1) {\n      parsedSdp.sdpParts[parsedSdp.index] = isInRemoteHold ? 'a=recvonly' : 'a=sendrecv'\n    }\n    return parsedSdp.sdpParts.join('\\r\\n')\n  }\n\n  /////////////////////////////////////////////\n  // Remote party has offered to resume.  Need to adjust if Local party still wants hold\n  private processSDPForResumeAnswer = (localSdp: string, isInLocalHold: boolean): string => {\n    const parsedSdp = this.parseSdpLinesForDirectionTag(localSdp)\n    if (parsedSdp.index > -1) {\n      parsedSdp.sdpParts[parsedSdp.index] = isInLocalHold ? 'a=sendonly' : 'a=sendrecv'\n    }\n    return parsedSdp.sdpParts.join('\\r\\n')\n  }\n\n  ///////////////////////////////////////////////\n  private isSrflxCandidate = (\n    candidate: RTCIceCandidateInit\n  ): { isSrflx: boolean; address: string; port: number; isIPV6: boolean } => {\n    const ric = new RTCIceCandidate(candidate)\n\n    const address = ric.address\n    return {\n      isSrflx: ric.type === 'srflx' && ric.protocol === 'udp',\n      address,\n      port: ric.port,\n      isIPV6: address.includes(':'),\n    }\n  }\n\n  ///////////////////////////////////////////////\n  private parseSdpForRemoteSessionDesc = (sdp: string): RTCSessionDescriptionInit => {\n    if (this.isSharing) {\n      const videoSdps = sdp.split('m=video')\n      for (const tempSdp of videoSdps) {\n        if (!tempSdp.includes('UDP/TLS/RTP/SAVP 117')) {\n          if (tempSdp.includes('m=audio')) {\n            sdp = tempSdp\n          } else {\n            let sdpVideo = tempSdp\n            if (sdpVideo.includes('m=video')) {\n              sdpVideo = sdpVideo.replace('m=video', '')\n            }\n            sdp += 'm=video'\n            sdp += sdpVideo\n          }\n        }\n      }\n    } else {\n      if (sdp.includes('a=content:slides')) {\n        const videoSdps = sdp.split('m=video')\n        for (const tempSdp of videoSdps) {\n          if (!tempSdp.includes('content:slides')) {\n            if (tempSdp.includes('m=audio')) {\n              sdp = tempSdp\n            } else {\n              let sdpVideo = tempSdp\n              if (sdpVideo.includes('m=video')) {\n                sdpVideo = sdpVideo.replace('m=video', '')\n              }\n              sdp += 'm=video'\n              sdp += sdpVideo\n            }\n          }\n        }\n      } else {\n        // Filter-out the 'a=mid:' sdp parameter\n        let sdpLines = sdp.split('\\r\\n')\n        sdpLines = sdpLines.filter((line) => !line.includes('a=mid:'))\n        sdp = sdpLines.join('\\r\\n')\n      }\n    }\n\n    // Return result as a SessionDescription\n    // The 'type' is set to the opposite of the 'this.isOfferer' value\n    // since this routine prepares an SDP for the remoteDescription\n    return {\n      sdp,\n      type: this.isOfferer ? 'answer' : 'offer',\n    } as RTCSessionDescriptionInit\n  }\n\n  /////////////////////////////////////////////\n  // Replace the IP address values in any line within the SDP\n  // with the chosen ice candidate's IP value\n  private setIPAddresses = (sdp: string, ipValue: string): string => {\n    if (!ipValue) {\n      this.logger.error('No Candidate or local client IP found.  Cannot process SDP')\n      return sdp\n    }\n\n    const replacementString = this.getReplacementString(ipValue)\n    const ip4Regx = new RegExp('IN IP4 [0-9.]+', 'g')\n    const ip6Regx = new RegExp('IN IP6 [0-9a-z.:]+', 'g')\n    return sdp\n      .split('\\r\\n')\n      .map((line) => {\n        if (line.includes('IN IP4')) {\n          line = line.replace(ip4Regx, replacementString)\n        } else if (line.includes('IN IP6')) {\n          line = line.replace(ip6Regx, replacementString)\n        }\n        return line\n      })\n      .join('\\r\\n')\n  }\n\n  /////////////////////////////////////////////\n  private getReplacementString = (candidateIP: string): string => {\n    const IPValue = candidateIP || ''\n    if (IPValue.includes(':')) {\n      // IPV6\n      return `IN IP6 ${IPValue}`\n    } else {\n      // IPV4\n      return `IN IP4 ${IPValue}`\n    }\n  }\n\n  ////////////////////////////////////////\n  // Find the direction 'a-tag' in the sdp.\n  // Return the direction tag, the index where it was found, and the disassembled sdp parts.\n  private parseSdpLinesForDirectionTag = (sdp: string): { direction: string; index: number; sdpParts: string[] } => {\n    if (typeof sdp === 'string') {\n      const sdpParts = sdp.split('\\r\\n') // sdp segments are always separated by '\\r\\n'.\n      // There should be only one direction 'a-tag', which can be one of four possibilities.\n      const index = sdpParts.findIndex((part) =>\n        ['a=inactive', 'a=recvonly', 'a=sendonly', 'a=sendrecv'].includes(part)\n      )\n      let direction = ''\n      if (index > -1) {\n        direction = sdpParts[index]\n      } else {\n        this.logger.warn('SDP is missing direction a-tag', sdp)\n      }\n      return { direction, index, sdpParts }\n    }\n    this.logger.warn('bad SDP input')\n    return { direction: '', index: -1, sdpParts: [] }\n  }\n\n  ///////////////////////////////////\n  // Set the outgoing video tag to match the remote video direction request\n  private setOutgoingVideoDirection = (sdp: string, remoteVideoDirection: string): string => {\n    const sdpComps = sdp.split('\\r\\n')\n    let foundVideo = false\n    for (let cmp of sdpComps) {\n      if (cmp.startsWith('m=video')) {\n        foundVideo = true\n      } else {\n        if (foundVideo) {\n          if (['a=inactive', 'a=recvonly', 'a=sendonly', 'a=sendrecv'].includes(cmp)) {\n            if (remoteVideoDirection === 'sendrecv') {\n              cmp = 'a=sendrecv'\n            } else if (remoteVideoDirection === 'recvonly') {\n              cmp = 'a=sendonly'\n            } else if (remoteVideoDirection === 'sendonly') {\n              cmp = 'a=recvonly'\n            } else {\n              cmp = 'a=inactive'\n            }\n            break\n          }\n        }\n      }\n    }\n    return sdpComps.join('\\r\\n')\n  }\n}\n", "import { SimplePubSub } from '../../common/libs/SimplePubSub'\nimport { Logger } from '../../common/libs/Logger'\nimport {\n  ApiStatus,\n  extractErrorMessages,\n  generateUUID,\n  getLastUrlSegment,\n  makeApiError,\n  makeApiSuccess,\n} from '../../common/libs/utils'\nimport { formatLineInfo, parseParticipantAddress } from '../../common/libs/line-utils'\nimport { CpaasServiceAccessors, WebSocketEventsInterface } from '../../api/cpaasCoreSdkInterfaces'\nimport { ConnectionStatus, DeviceType, WebRtcAPIs, WebRtcSignaler } from './WebRtcAPIs'\nimport { CallManagerConfig } from '../../api/CallManager'\n\n/**\n * @internal\n */\nexport interface CallSession {\n  callId: string\n  callObjectRefUrl: string\n  callTransferSuccess?: string\n  iAmOriginator: boolean // I am the originator of this call\n  isConference: boolean // Is this a conference call\n  isLocalHold: boolean // hold generated by local client\n  isRecvAttendedXfer: boolean // Is in the process of receiving an attended/warm call xfer\n  isRemoteHold: boolean // hold generated by remote client\n  lineInfo: string\n  muteStateBeforeLocalHold: boolean // records the mute state before going on local hold\n  offerSdp?: string\n  originator: string\n  originatorName: string\n  pidflo?: string\n  relatedSessionId: string\n  remoteSdp?: string\n  serverCorrelator?: string\n  sessionId: string\n  terminator: string\n  terminatorName: string\n  videoPauseStateBeforeLocalHold: boolean // records the video Pause state before going on local hold\n  webRtcObj: WebRtcAPIs\n}\n\n/**\n * @internal\n */\ninterface CallSessionMap {\n  callId?: CallSession\n}\n\n/**\n * @internal\n */\ntype CallingApiEvents =\n  | 'OnCallDowngradedToAudio' // Called when the remote declines to send or receive video\n  | 'OnConferenceParticipantUpdate'\n  | 'OnLocalStream' // called when local stream is created or changes\n  | 'OnReceivedCallActive'\n  | 'OnReceivedCallEnded'\n  | 'OnReceivedCallFailed'\n  | 'OnReceivedCallHold'\n  | 'OnReceivedCallRejected'\n  | 'OnReceivedCallResume'\n  | 'OnReceivedCallStatus'\n  | 'OnReceivedNewCall'\n  | 'OnReceivedNewScreenShare' // not supported at this time\n  | 'OnReceivedScreenShareEnded' // not supported at this time\n  | 'OnReceivedUpgradeCallToMeeting'\n  | 'OnRemoteStream' // called when remote stream created or changes\n  | 'OnRemoteVideoDropped' // Called when remote side has removed their video\n  | 'OnRemoteVideoReceived' // Called when received and accepted offer from remote side to send video\n  | 'OnRemoteVideoUpgradeRequest' // called when remote side request video upgrade\n  | 'OnTransferTargetDetails'\n  | 'OnVideoUpgradeDeclined' // called when remote side declined our offer to send video\n\n// const TMOBILE_EMAIL_SUFFIX = '@msg.pc.t-mobile.com'\n\nexport class DaasCallingAPIs {\n  private static instance: DaasCallingAPIs\n\n  private callSessionMap: CallSessionMap = {}\n\n  private cfg: CallManagerConfig\n\n  private cpaasBaseUrl: string\n\n  private cpaasCallUrl: string\n\n  private cpaasServiceAPIs: CpaasServiceAccessors\n\n  private isCallTransfer: boolean = false\n\n  private pubsub: SimplePubSub<CallingApiEvents>\n\n  private readonly logger: Logger\n\n  private readonly signaler: WebRtcSignaler\n\n  private turnServerIp: string = ''\n\n  private turnServerUdpPort: string = ''\n\n  private webSocketAPIs: WebSocketEventsInterface\n\n  /**\n   * The Singleton's constructor should always be private to prevent direct\n   * construction calls with the `new` operator.\n   */\n  private constructor() {\n    this.logger = new Logger('DAAS_CALL_API')\n\n    this.pubsub = new SimplePubSub<CallingApiEvents>(this.logger)\n\n    // Initialize the signaler to be used for callbacks from the WebRTC class instances\n    this.signaler = {\n      onCallDowngradedToAudio: (callId: string) => this.onCallDowngradedToAudio(callId),\n      onLocalStream: (callId: string, stream: MediaStream, hasVideo: boolean) =>\n        this.onLocalStream(callId, stream, hasVideo),\n      onReceivedCallEnded: (callId: string) => this.onReceivedCallEnded(callId),\n      onReceivedCallFailed: (callId: string, failureCode: number) => this.onReceivedCallFailed(callId, failureCode),\n      onRemoteStream: (callId: string, stream: MediaStream, hasVideo: boolean) =>\n        this.onRemoteStream(callId, stream, hasVideo),\n    } as WebRtcSignaler\n  }\n\n  /**\n   * The static method that controls the access to the singleton instance.\n   *\n   * This implementation let you subclass the Singleton class while keeping\n   * just one instance of each subclass around.\n   */\n  public static getInstance = (): DaasCallingAPIs => {\n    if (!DaasCallingAPIs.instance) {\n      DaasCallingAPIs.instance = new DaasCallingAPIs()\n    }\n\n    return DaasCallingAPIs.instance\n  }\n\n  /**\n   * @internal  hide from external documentation\n   * Initializes the DaasCallingAPIs\n   * Pass in initial configuration since constructor is private in Singleton pattern\n   */\n  public initialize = (\n    callingConfig: CallManagerConfig,\n    cpaasServiceAccessors: CpaasServiceAccessors,\n    wsEventsMgr: WebSocketEventsInterface\n  ): void => {\n    this.cfg = callingConfig\n\n    this.cpaasBaseUrl = `${cpaasServiceAccessors.cpaasRootUrl}/cpaas/v1`\n    this.cpaasCallUrl = `${this.cpaasBaseUrl}/call`\n\n    this.cpaasServiceAPIs = cpaasServiceAccessors\n    this.webSocketAPIs = wsEventsMgr\n\n    const turnConfig = {\n      domain: this.cfg.turnServerDomain || 'stun.l.google.com',\n      port: this.cfg.turnServerPort > 0 ? this.cfg.turnServerPort : 19302,\n    }\n    this.setTurnServerDetails(turnConfig.domain, String(turnConfig.port))\n\n    // // Register subscriptions to WebSocket events\n    // this.webSocketAPIs.subscribe(\n    //   'WS_conferenceParticipantStatusNotification',\n    //   this.conferenceParticipantHandler,\n    //   'callingApis'\n    // )\n    // this.webSocketAPIs.subscribe(\n    //   'WS_conferenceSessionInvitationNotification',\n    //   this.conferenceInvitationHandler,\n    //   'callingApis'\n    // )\n    this.webSocketAPIs.subscribe('WS_sessionInvitationNotification', this.callSessionInvitationHandler, 'callingApis')\n    this.webSocketAPIs.subscribe(\n      'WS_sessionStatusNotification',\n      this.callSessionStatusNotificationHandler,\n      'callingApis'\n    )\n    this.webSocketAPIs.subscribe('WS_vvoipSessionTransferNotification', this.vvoipSessionTransferHandler, 'callingApis')\n  }\n\n  /**\n   *\n   * @param eventName\n   * @param callback\n   * @param identifier\n   */\n  public subscribe = (eventName: CallingApiEvents, callback: (..._args: any) => void, identifier: string): number => {\n    return this.pubsub.subscribe(eventName, callback, identifier)\n  }\n\n  /**\n   *\n   * @param eventName\n   * @param identifier\n   */\n  public unsubscribe = (eventName: CallingApiEvents, identifier: string): number => {\n    return this.pubsub.unsubscribe(eventName, identifier)\n  }\n\n  private publishEvent = (eventName: CallingApiEvents, ...args: any): void => {\n    this.pubsub.publish(eventName, ...args)\n  }\n\n  //////////////////////////////////////////////////////////////////////\n  // PubSub wrappers.\n  //////////////////////////////////////////////////////////////////////\n\n  private onCallDowngradedToAudio = (callId: string): void => {\n    this.publishEvent('OnCallDowngradedToAudio', callId)\n  }\n\n  // private onConferenceParticipantUpdate = (callId: string): void => {\n  //   // this.logger.log('OnConferenceParticipantUpdate', callId)\n  //   this.publishEvent('OnConferenceParticipantUpdate', callId)\n  // }\n\n  private onLocalStream = (callId: string, stream: MediaStream, hasVideo: boolean): void => {\n    this.publishEvent('OnLocalStream', callId, stream, hasVideo)\n  }\n\n  private onReceivedCallActive = (callId: string): void => {\n    // this.logger.log('onReceivedCallActive')\n    this.publishEvent('OnReceivedCallActive', callId)\n  }\n\n  private onReceivedCallEnded = (callId: string): void => {\n    this.publishEvent('OnReceivedCallEnded', callId)\n  }\n\n  private onReceivedCallFailed = (callId: string, failureCode: number): void => {\n    this.publishEvent('OnReceivedCallFailed', callId, failureCode)\n  }\n\n  private onReceivedCallHold = (callId: string): void => {\n    this.publishEvent('OnReceivedCallHold', callId)\n  }\n\n  private onReceivedCallRejected = (callId: string): void => {\n    this.publishEvent('OnReceivedCallRejected', callId)\n  }\n\n  private onReceivedCallResume = (callId: string): void => {\n    this.publishEvent('OnReceivedCallResume', callId)\n  }\n\n  private onReceivedCallStatus = (callId: string, responseCode: number): void => {\n    this.publishEvent('OnReceivedCallStatus', callId, responseCode)\n  }\n\n  private onReceivedNewCall = (\n    callId: string,\n    originatorAddress: string,\n    originatorName: string,\n    receiverAddress: string,\n    receiverName: string,\n    serverCorrelator: string,\n    relatedSessionId: string,\n    isVideo: boolean\n  ): void => {\n    this.publishEvent(\n      'OnReceivedNewCall',\n      callId,\n      originatorAddress,\n      originatorName,\n      receiverAddress,\n      receiverName,\n      serverCorrelator,\n      relatedSessionId,\n      isVideo\n    )\n  }\n\n  private onReceivedNewScreenShare = (callId: string, originator: string): void => {\n    this.publishEvent('OnReceivedNewScreenShare', callId, originator)\n  }\n\n  private onReceivedScreenShareEnded = (callId: string): void => {\n    this.publishEvent('OnReceivedScreenShareEnded', callId)\n  }\n\n  // private onReceivedUpgradeCallToMeeting = (callId: string): void => {\n  //   this.publishEvent('OnReceivedUpgradeCallToMeeting', callId)\n  // }\n\n  private onRemoteStream = (callId: string, stream: MediaStream, hasVideo: boolean): void => {\n    this.publishEvent('OnRemoteStream', callId, stream, hasVideo)\n  }\n\n  private onRemoteVideoDropped = (callId: string): void => {\n    this.publishEvent('OnRemoteVideoDropped', callId)\n  }\n\n  private onRemoteVideoReceived = (callId: string): void => {\n    this.publishEvent('OnRemoteVideoReceived', callId)\n  }\n\n  private onRemoteVideoUpgradeRequest = (callId: string): void => {\n    this.publishEvent('OnRemoteVideoUpgradeRequest', callId)\n  }\n\n  private onTransferTargetDetails = (callId: string, sessionData: any): void => {\n    this.publishEvent('OnTransferTargetDetails', callId, sessionData)\n  }\n\n  // private onVideoUpgradeDeclined = (callId: string): void => {\n  //   this.publishEvent('OnVideoUpgradeDeclined', callId)\n  // }\n\n  //////////////////////////////////////////////////////////////////////\n  // CALLING API Methods\n  //////////////////////////////////////////////////////////////////////\n\n  /**\n   * Sets the required WebRTC Turn Server IP and Port values.\n   * !!!!! This method must be called before any calls can be created or received\n   * @param turnServerIp\n   * @param turnServerUdpPort\n   */\n  public setTurnServerDetails = (turnServerIp: string, turnServerUdpPort: string): void => {\n    this.logger.log('Setting TURN IP:', turnServerIp, ' Port:', turnServerUdpPort)\n    this.turnServerIp = turnServerIp\n    this.turnServerUdpPort = turnServerUdpPort\n  }\n\n  /**\n   *\n   * @param mtLine Destination msisdn\n   * @param isVideo\n   * @param callId\n   * @param lineInfo\n   * @param relatedSessionId\n   * @param originatorName\n   * @param deviceList\n   * @param isConference\n   * @returns Promise<string>: the new callId returned by the network\n   */\n  public startCall = async (\n    mtLine: string,\n    isVideo: boolean,\n    callId: string,\n    lineInfo: string,\n    relatedSessionId: string,\n    originatorName: string,\n    deviceList?: MediaDeviceInfo[]\n  ): Promise<string> => {\n    if (!mtLine || !callId || !lineInfo) {\n      return Promise.reject(makeApiError('startCall missing required parameters', -1))\n    }\n\n    const callSession = this.createCallSession(callId, lineInfo, lineInfo, originatorName, mtLine, '')\n    if (!callSession) {\n      return Promise.reject(makeApiError('Failed to create new CallSession object', -2))\n    }\n    callSession.iAmOriginator = true\n    callSession.webRtcObj.setHasOutgoingVideo(isVideo)\n    callSession.relatedSessionId = relatedSessionId\n\n    this.saveCallSession(callId, callSession)\n    try {\n      const localSdp = await callSession.webRtcObj.createOfferWithDeviceList(deviceList)\n      return await this.sendCallStart(callId, localSdp)\n    } catch (err) {\n      this.logger.error('startCall Error: ', extractErrorMessages(err))\n      this.clearCallSession(callId)\n      return Promise.reject(err)\n    }\n  }\n\n  /**\n   * endCall\n   * @param callId\n   * @param {boolean} endedLocally: indicates if call ended because of local action\n   */\n  public endCall = async (callId: string, endedLocally: boolean): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const webRtcObj = callSession.webRtcObj\n    // Close the webRtc connection right away to end the voice/video streaming\n    // in case there is a delay completing the network call to 'end'\n    webRtcObj.closePeerConnections()\n\n    if (endedLocally) {\n      // The call session only needs to be deleted when ended locally.\n      // Don't do for calls that were ended remotely.\n      await this.sendCallEnd(callId)\n    }\n\n    // Always send 'Call Ended' notification regardless of response to deleteFetch\n    if (webRtcObj.getIsSharing()) {\n      this.onReceivedScreenShareEnded(callSession.callId)\n    } else {\n      this.onReceivedCallEnded(callSession.callId)\n    }\n\n    await this.clearCallSession(callId)\n  }\n\n  /**\n   * acceptCall\n   * @param callId\n   * @param deviceList\n   * @param acceptIncomingVideo\n   * @param provideOutgoingVideo\n   */\n  public acceptCall = async (\n    callId: string,\n    deviceList: MediaDeviceInfo[],\n    acceptIncomingVideo: boolean = false,\n    provideOutgoingVideo: boolean = false\n  ): Promise<void> => {\n    this.logger.log(\n      '\\ncallId: ',\n      callId,\n      '\\ndeviceList: ',\n      deviceList,\n      '\\nallowIncomingVideo: ',\n      acceptIncomingVideo,\n      '\\nprovideOutgoingVideo: ',\n      provideOutgoingVideo\n    )\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    try {\n      if (this.isCallTransfer) {\n        this.isCallTransfer = false\n        const localSdp = await callSession.webRtcObj.createOfferWithDeviceList(deviceList)\n        await this.sendTransferOfferSdp(callId, localSdp)\n      } else {\n        const localSdp = await callSession.webRtcObj.acceptIncomingCallInvitation(\n          deviceList,\n          acceptIncomingVideo,\n          provideOutgoingVideo\n        )\n        // await this.sendSdpAndStatus(callId, localSdp, 'Connected', '200')\n        await this.sendCallConnected(callId, localSdp)\n      }\n    } catch (error) {\n      this.onReceivedCallFailed(callId, 1)\n      this.logger.error('acceptCall Error: ', extractErrorMessages(error))\n      this.clearCallSession(callId)\n      return Promise.reject(error)\n    }\n  }\n\n  /**\n   * rejectCall\n   * @param callId\n   * @param reason\n   */\n  public rejectCall = async (callId: string, reason?: string): Promise<void> => {\n    await this.sendDeleteSessionNotify(callId, reason)\n    await this.clearCallSession(callId)\n  }\n\n  /**\n   * muteCall\n   * @param callId\n   * @returns void\n   */\n  public muteCall = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n\n    if (callSession.isLocalHold) {\n      callSession.muteStateBeforeLocalHold = true\n    } else {\n      if (!callSession.webRtcObj.toggleCallMute(true)) {\n        return Promise.reject(makeApiError('Error muting call'))\n      }\n    }\n    return Promise.resolve()\n  }\n\n  /**\n   *\n   * @param callId\n   */\n  public unmuteCall = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n\n    if (callSession.isLocalHold) {\n      callSession.muteStateBeforeLocalHold = false\n    } else {\n      if (!callSession.webRtcObj.toggleCallMute(false)) {\n        return Promise.reject(makeApiError('Error Unmuting call'))\n      }\n    }\n    return Promise.resolve()\n  }\n\n  /**\n   *\n   * @param callId\n   */\n  public isCallMuted = (callId: string): boolean => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return false\n    }\n    if (callSession.isLocalHold) {\n      return callSession.muteStateBeforeLocalHold\n    }\n    return callSession.webRtcObj.getIsMuted()\n  }\n\n  /**\n   * holdCall\n   * @param callId\n   * returns Promise\n   */\n  public holdCall = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    await this.toggleCallHold(callSession, true)\n  }\n\n  /**\n   * Resume from Hold\n   * @param callId\n   */\n  public resumeCall = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n\n    const status: ConnectionStatus = callSession.webRtcObj.getStatus()\n    // If a video call is downgraded to audio after getting parked on MRF,\n    // then the status will be 'VideoDowngrade' rather than 'Hold'\n    // 'Resume' case is for Double Hold scenario\n\n    if (['Hold', 'Resume', 'VideoDowngrade'].includes(status)) {\n      // Resume call.  Check mute state before, and restore it after resuming\n      await this.toggleCallHold(callSession, false)\n    }\n  }\n\n  /**\n   *\n   * @param callId\n   */\n  public isCallOnHold = (callId: string): boolean => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return false\n    }\n\n    return callSession.isRemoteHold || callSession.isLocalHold\n  }\n\n  /**\n   *\n   * @param callId\n   */\n  public pauseVideoCall = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n\n    if (callSession.webRtcObj.getIsPaused()) {\n      // video is already paused\n      return Promise.resolve()\n    }\n\n    await callSession.webRtcObj.toggleCallVideoPaused(true)\n  }\n\n  /**\n   *\n   * @param callId\n   */\n  public resumeVideoCall = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    if (callSession.isLocalHold) {\n      callSession.videoPauseStateBeforeLocalHold = false\n    } else {\n      if (!callSession.webRtcObj.getIsPaused()) {\n        // video is already in resume state\n        return Promise.resolve()\n      }\n\n      await callSession.webRtcObj.toggleCallVideoPaused(false)\n    }\n  }\n\n  /**\n   *\n   * @param callId\n   */\n  public isVideoCallPaused = (callId: string): boolean => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return false\n    }\n    if (callSession.isLocalHold) {\n      return callSession.videoPauseStateBeforeLocalHold\n    }\n    return callSession.webRtcObj.getIsPaused()\n  }\n\n  /**\n   * Sends a string of one or more DTMF codes\n   * DTMF codes can be 0-9, '*','#', or ','\n   * Comma dtmf codes inserts a 2 second delay.\n   * @param callId\n   * @param dtmfCodes\n   * @param onToneChangeCB callback handler for when the tone has completed. Retuns a string for the tone that just completed\n   */\n  public sendDtmfCodes = (callId: string, dtmfCodes: string, onToneChangeCB?: (_s: string) => void): ApiStatus => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return makeApiError('Could not find indicated CallSession', -1)\n    }\n\n    callSession.webRtcObj.sendDtmfCodes(dtmfCodes, onToneChangeCB)\n    return makeApiSuccess()\n  }\n\n  /**\n   * Accept the remote party's offer to provide video.\n   * This API is automatically called if the calling configuration autoAcceptVideoUpgrade.enabled = true\n   * Otherwise this API is called via the Call object once the user accepts the video upgrade request\n   * @param callId\n   * @param remoteSdp\n   * @param status\n   */\n  public acceptRemoteVideoUpgrade = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n\n    const newSdp = await callSession.webRtcObj.createAnswerForAddRemoteVideo(callSession.remoteSdp)\n    // await this.sendSdpAndStatus(callSession.callId, newSdp, 'Connected', '200')\n    await this.sendCallConnected(callSession.callId, newSdp)\n  }\n\n  /**\n   * Reject the remote party's offer to send video\n   * This API is only called vid the Call object in response to the user rejecting video update.\n   * @param callId\n   */\n  public rejectRemoteVideoUpgrade = async (callId: string): Promise<void> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n\n    const newSdp = await callSession.webRtcObj.createAnswerToRejectRemoteVideoUpdate(callSession.remoteSdp)\n    // await this.sendSdpAndStatus(callSession.callId, newSdp, 'Connected', '200')\n    await this.sendCallConnected(callSession.callId, newSdp)\n  }\n\n  /**\n   * reconnectCall\n   * Call this method if client losses internet connection momentarily.\n   * Method tests if the session is still active, and if it still active,\n   * re-triggers the stream flow, then returns true\n   * If Session has closed, send 'OnReceivedCallEnded' and return false.\n   * @param callId\n   */\n  public reconnectCall = async (callId: string): Promise<boolean> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      throw makeApiError('Could not find indicated CallSession', -1)\n    }\n\n    const webRtcObj = callSession.webRtcObj\n    const pc = webRtcObj.getPeerConnection()\n    if (pc && pc.connectionState === 'connected') {\n      await webRtcObj.initiateOfferProcess()\n      this.onReceivedCallActive(callId)\n      return true\n    }\n    // Session No longer connected\n    this.onReceivedCallEnded(callId)\n    return false\n  }\n\n  /**\n   * Closes the RTC connections, and removes the local callSession record\n   * @param callId\n   * Was called clearAllData\n   */\n  public clearCallSession = (callId: string): void => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      this.logger.error('clearCallSession could not find call session: ', callId)\n      return\n    }\n    callSession.webRtcObj.closePeerConnections()\n    this.removeCallSession(callId)\n  }\n\n  /**\n   * Gets the Call resourceURL\n   * @param callId\n   */\n  public getCallSessionUrl = (callId: string): string => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      this.logger.error('getCallSessionUrl could not find call session: ', callId)\n      return ''\n    }\n\n    return callSession.callObjectRefUrl\n  }\n\n  /**\n   * Change the Microphone or Camera device associated with the current output\n   * stream sent to the peer, without having to do a full sdp renegotiation.\n   * @param callId {string}\n   * @param kind {DeviceType}\n   * @param mediaDeviceId {string}\n   */\n  public updateMediaDevice = async (callId: string, kind: DeviceType, mediaDeviceId: string): Promise<void> => {\n    let userMediaConstraints: MediaStreamConstraints\n    switch (kind) {\n      case 'audioinput':\n        userMediaConstraints = { audio: { deviceId: { exact: mediaDeviceId } } }\n        break\n      case 'videoinput':\n        userMediaConstraints = { video: { deviceId: { exact: mediaDeviceId } } }\n        break\n      default:\n        return Promise.reject(makeApiError('Cannot match device type', -1))\n    }\n\n    const stream = await navigator.mediaDevices.getUserMedia(userMediaConstraints)\n    let newTrack\n    switch (kind) {\n      case 'audioinput':\n        newTrack = stream.getAudioTracks()[0]\n        break\n      case 'videoinput':\n        newTrack = stream.getVideoTracks()[0]\n        break\n    }\n\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      this.logger.error('updateMediaDevice could not find call session: ', callId)\n      return Promise.reject(makeApiError('Cannot find callSession', -2))\n    }\n\n    await callSession.webRtcObj.replaceTrack(newTrack)\n  }\n\n  /**\n   * Helpful for unit testing\n   */\n  public getSignalerObject = (): WebRtcSignaler => {\n    return this.signaler\n  }\n\n  /**\n   * Waits for the webrtc ICE Candidate collection process to complete and write\n   * the offer sdp into the selected callSession\n   * The SDP make take some time to show up, depending on the webrtc ICE discovery process\n   * Wait a maximum of 60 seconds for sdp to show up, or return error\n   * @return Promise<void>: sdp string\n   */\n  public waitForOfferSdp = (callId: string): Promise<string> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated callSession', -1))\n    }\n\n    // Check if the offerSdp is already there\n    if (callSession.offerSdp) {\n      return Promise.resolve(callSession.offerSdp)\n    }\n\n    const startTime = Date.now()\n    const maxWaitTime = 60 * 1000 // 60 seconds\n\n    return new Promise((resolve, reject) => {\n      const interval = window.setInterval(() => {\n        if (callSession.offerSdp) {\n          window.clearInterval(interval)\n          resolve(callSession.offerSdp)\n        }\n        if (Date.now() > startTime + maxWaitTime) {\n          window.clearInterval(interval)\n          reject(makeApiError('Timeout waiting for offerSdp'))\n        }\n      }, 100)\n    })\n  }\n\n  /**\n   *\n   * @param detailed\n   */\n  public showAllCallStatus = (detailed?: boolean): void => {\n    const callSessions = this.getAllCallSessions()\n    for (const cs of callSessions) {\n      const webrtc = cs.webRtcObj\n      webrtc.showStreamStatus(detailed)\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Private Worker Methods Below here\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  //////////////////////\n  // Not currently used, but save for possible use later on\n  // private putAllOtherCallsOnHold = (activeCallId: string): Promise<void> => {\n  //   const callSessions = this.getAllCallSessions()\n  //   const callHoldRequests: Promise<void>[] = []\n  //   for (const cs of callSessions) {\n  //     if (cs.callId !== activeCallId && !cs.isLocalHold) {\n  //       callHoldRequests.push(this.toggleCallHold(cs, true))\n  //     }\n  //   }\n  //   return Promise.all(callHoldRequests).then(() => Promise.resolve())\n  // }\n\n  //////////////////////////\n  private sendSessionStatus = async (callSession: CallSession): Promise<void> => {\n    const callId = callSession.callId\n    // const resp = await this.sendSdpAndStatus(callId, null, 'InProgress', '183')\n    await this.sendCallInProgress(callSession.callId, '') // 183, but we don't yet have a local sdp\n\n    if (callSession.webRtcObj.getIsSharing()) {\n      this.onReceivedNewScreenShare(callId, callSession.originator)\n    } else {\n      this.onReceivedNewCall(\n        callId,\n        callSession.originator,\n        callSession.originatorName,\n        callSession.terminator,\n        callSession.terminatorName,\n        callSession.serverCorrelator,\n        callSession.relatedSessionId,\n        callSession.webRtcObj.getIsVideo()\n      )\n      this.sendCallIsRinging(callSession.callId) // 180\n        .catch(() => Promise.resolve())\n    }\n    return Promise.resolve()\n  }\n\n  //////////////////////////\n  private processNewIncomingCall = async (callSession: CallSession): Promise<void> => {\n    const callId = callSession.callId\n    // Send the network a 180 (isRinging) status.  The status string value is still 'InProgress'\n    // even though this is for 180-isRinging\n    // const resp = await this.sendSdpAndStatus(callId, null, 'InProgress', '180')\n    const resp = await this.sendCallIsRinging(callId)\n\n    if (resp.ok) {\n      if (callSession.webRtcObj.getIsSharing()) {\n        this.onReceivedNewScreenShare(callId, callSession.originator)\n      } else {\n        this.onReceivedNewCall(\n          callId,\n          callSession.originator,\n          callSession.originatorName,\n          callSession.terminator,\n          callSession.terminatorName,\n          callSession.serverCorrelator,\n          callSession.relatedSessionId,\n          callSession.webRtcObj.getHasIncomingVideo()\n        )\n      }\n      return Promise.resolve()\n    } else {\n      throw resp\n    }\n  }\n\n  /////////////////\n  // Private method used for WebRtc Signaling\n  // To send acceptance of Cold/Blind Transfer\n  private sendTransferOfferSdp = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      throw makeApiError('Could not find indicated CallSession', -1)\n    }\n\n    // Consumer Network transfer process is a bit different than on UCC network.\n    // On Consumer we send 'In-Progress' status 183, then 'Connected' status 200 with sdp\n\n    // Transition from Cold xFer with 'InProgress'-183, and then 'Connected'-200-with-sdp\n    // let resp = await this.sendSdpAndStatus(callId, undefined, 'InProgress', '183')\n    let resp = await this.sendCallInProgress(callId, undefined)\n    if (resp.ok) {\n      // resp = await this.sendSdpAndStatus(callId, sdp, 'Connected', '200')\n      resp = await this.sendCallConnected(callId, sdp)\n      if (resp.ok) {\n        if (resp.data?.receiverSessionStatus) {\n          const sdp = resp.data.receiverSessionStatus.sdp\n          await callSession.webRtcObj.setRemoteSessionDescriptionFromSdp(sdp, true)\n          this.onReceivedCallActive(callId)\n        } else {\n          resp = makeApiError('Missing expected response data fields', -1)\n        }\n      }\n    }\n    return resp\n  }\n\n  /////////////////\n  // Private method used for WebRtc Signaling\n  // To send acceptance of Attended/Warm Transfer\n  private sendTransferConnectedStatusAttended = async (callSession: CallSession): Promise<void> => {\n    // Setup for this client being about to receive a Warm Transfer or MT has done a Switch Device.\n    // Create an new offer and send it to WRG.  WRG will respond to offer with 'Connected' WS message\n    const webRtcObj = callSession.webRtcObj\n    await webRtcObj.initiateOfferProcess()\n    const sdp = webRtcObj.getCurrentLocalDescription().sdp\n    // const resp = await this.sendSdpAndStatus(callSession.callId, sdp, 'Connected', '200')\n    const resp = await this.sendCallConnected(callSession.callId, sdp)\n    if (resp.ok) {\n      return Promise.resolve()\n    }\n    return Promise.reject(resp)\n  }\n\n  /////////////////\n  // End the call when user rejects it.\n  private sendDeleteSessionNotify = async (callId: string, reason?: string): Promise<void> => {\n    await this.sendCallEnd(callId, reason)\n\n    const callSession = this.getCallSession(callId)\n    if (callSession?.webRtcObj) {\n      const webRtcObj = callSession.webRtcObj\n      if (!webRtcObj.getIsSharing()) {\n        this.onReceivedCallRejected(callId)\n      }\n    }\n  }\n\n  /////////////////\n  // Private method used for WebRtc Signaling\n  // Gets called when webrtc ICE candidate selection completes and has an offerSDP for us.\n  // Returns the new callId value created by the network\n  private sendCallStart = async (callId: string, offerSdp: string): Promise<string> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    callSession.offerSdp = offerSdp\n    if (callSession.isConference) {\n      callSession.webRtcObj.setStatus('InProgress')\n      return Promise.resolve(callId)\n    }\n\n    if (callSession.pidflo) {\n      return Promise.reject('Emergency Calls not handled')\n    }\n\n    const url = `${this.cpaasCallUrl}/start`\n    const data = JSON.stringify({\n      from: callSession.lineInfo,\n      to: callSession.terminator,\n      sdp: offerSdp,\n      clientCorrelator: generateUUID(),\n    })\n\n    const headers = {}\n\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, headers, data)\n    if (resp.ok && resp.data?.callId) {\n      callSession.callId = resp.data.callId\n      callSession.sessionId = callSession.callId\n      this.removeCallSession(callId) // remove the temporary callSession used during call creation\n      this.saveCallSession(callSession.callId, callSession)\n      return Promise.resolve(callSession.callId)\n    } else {\n      callSession.webRtcObj.closePeerConnections()\n      this.logger.warn('Error sending Call Start request.', resp.status)\n      return Promise.reject(resp)\n    }\n  }\n\n  //////////////////////\n  // Private method used to notify network that the call is in the 'Ringing' stat\n  private sendCallIsRinging = async (callId: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/ringing/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, undefined)\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call isRinging status.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallIsRinging error', resp.status))\n    }\n    // callSession.webRtcObj.setStatus('Proceeding')\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network to resume the call\n  private sendCallResume = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/resume/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call Resume request.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallResume error', resp.status))\n    }\n\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network we accept the resume offer\n  private sendCallAcceptResume = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/acceptResume/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call AcceptResume response.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallAcceptResume error', resp.status))\n    }\n\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network the call is in the 'Proceeding' state\n  private sendCallProceeding = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/proceeding/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call Proceeding status.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallProceeding error', resp.status))\n    }\n    // callSession.webRtcObj.setStatus('Proceeding')\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network the call is in 'InProgress' state\n  private sendCallInProgress = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/inProgress/${callId}`\n    const sdpStr = JSON.stringify({ sdp })\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, sdpStr)\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call InProgress status.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallInProgress error', resp.status))\n    }\n    // callSession.webRtcObj.setStatus('InProgress')\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network to put the call on Hold\n  private sendCallHold = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/hold/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call Hold request.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallHold error', resp.status))\n    }\n\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network we accept the Hold request\n  private sendCallAcceptHold = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/acceptHold/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call AcceptHold response.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallAcceptHold error', resp.status))\n    }\n\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network we accept the Hold request\n  private sendCallConnected = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/connected/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call Connected status.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallConnected error', resp.status))\n    }\n    // callSession.webRtcObj.setStatus('Connected')\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network of an updated call sdp\n  private sendCallUpdate = async (callId: string, sdp: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/update/${callId}`\n    const resp = await this.cpaasServiceAPIs.cpaasPostFetch(url, {}, JSON.stringify({ sdp }))\n    if (!resp.ok) {\n      this.logger.warn('Error sending Call Update request.', resp.status)\n      this.onReceivedCallFailed(callId, resp.status)\n      return Promise.reject(makeApiError('sendCallUpdate error', resp.status))\n    }\n    // callSession.webRtcObj.setStatus('Connected')\n    return Promise.resolve(resp)\n  }\n\n  //////////////////////\n  // Private method used to notify network the call has ended on this side\n  private sendCallEnd = async (callId: string, reason?: string): Promise<ApiStatus> => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return Promise.reject(makeApiError('Could not find indicated CallSession', -1))\n    }\n    const url = `${this.cpaasCallUrl}/end/${callId}`\n    const headers = {}\n    headers['Conference'] = callSession.isConference ? 'true' : 'false'\n    headers['Reason'] = reason || 'NORMAL_USER_DISCONNECT'\n\n    const resp = await this.cpaasServiceAPIs.cpaasDeleteFetch(url, headers)\n    if (!resp.ok) {\n      return Promise.reject(makeApiError('sendCallEnd error', resp.status))\n    }\n    // callSession.webRtcObj.setStatus('Disconnected')\n    return Promise.resolve(resp)\n  }\n\n  /////////////////////////////////////////\n  private createCallSession = (\n    callId: string,\n    lineInfo: string,\n    originator: string,\n    originatorName: string,\n    terminator: string,\n    terminatorName: string\n  ): CallSession => {\n    if (!this.turnServerIp && !this.turnServerUdpPort) {\n      this.logger.error('createCallSession Error: TURN Server IP and UDP port must be defined')\n      return undefined\n    }\n\n    const webRtcObj = new WebRtcAPIs(callId, this.signaler, this.turnServerIp, this.turnServerUdpPort)\n    if (originator.startsWith('+1')) {\n      originator = originator.replace('+1', '1')\n    }\n    if (terminator.startsWith('+1')) {\n      terminator = terminator.replace('+1', '1')\n    }\n\n    return {\n      callId: callId,\n      callObjectRefUrl: '',\n      iAmOriginator: false,\n      isLocalHold: false,\n      isRecvAttendedXfer: false,\n      isRemoteHold: false,\n      lineInfo: formatLineInfo(lineInfo),\n      originator: originator,\n      originatorName: originatorName,\n      relatedSessionId: '',\n      sessionId: '',\n      terminator: terminator,\n      terminatorName: terminatorName,\n      webRtcObj: webRtcObj,\n    } as CallSession\n  }\n\n  /**\n   * getCallSession\n   * Retrieves the indicated CallSession from the Map\n   * @param callId\n   */\n  public getCallSession = (callId: string): CallSession => {\n    if (!callId) {\n      return undefined\n    }\n    return this.callSessionMap[callId] as CallSession\n  }\n\n  /**\n   * saveCallSession\n   * Adds a callSession to the Map.  Over-writes any existing callSession record\n   * with the same CallId value.\n   * @param callId\n   * @param callSession\n   */\n  private saveCallSession = (callId: string, callSession: CallSession): void => {\n    if (!callId || !callSession) {\n      return\n    }\n    this.callSessionMap[callId] = callSession\n  }\n\n  /////////////////\n  private removeCallSession = (callId: string): void => {\n    const callSession = this.getCallSession(callId)\n    if (!callSession) {\n      return\n    }\n    delete this.callSessionMap[callId]\n  }\n\n  /////////////////\n  private getAllCallSessions = (): CallSession[] => {\n    const csArr: CallSession[] = []\n    const keys = Object.keys(this.callSessionMap)\n    for (const key of keys) {\n      csArr.push(this.callSessionMap[key])\n    }\n    return csArr\n  }\n\n  /////////////////\n  private findCallSessionBySessionId = (sessionId: string): CallSession => {\n    if (!sessionId) {\n      return undefined\n    }\n\n    const keys = Object.keys(this.callSessionMap)\n    for (const key of keys) {\n      const cs = this.callSessionMap[key]\n      if (cs.sessionId === sessionId) {\n        return cs\n      }\n    }\n    return undefined\n  }\n\n  ////////////////////////////\n  // Calls Hold or Resume if call is not already in that state\n  private toggleCallHold = async (callSession: CallSession, putOnHold: boolean): Promise<void> => {\n    if (putOnHold) {\n      if (!callSession.isLocalHold) {\n        // Only call Hold Process if not already in Local Hold\n        await this.doHoldProcess(callSession, false)\n      }\n    } else {\n      if (callSession.isLocalHold) {\n        await this.doResumeProcess(callSession)\n      }\n    }\n  }\n\n  ////////////////////////////////////////\n  // private putCallIntoInactiveHold = async (callSession: CallSession): Promise<void> => {\n  //   this.logger.log('Putting Call into Inactive Hold')\n  //   await this.doHoldProcess(callSession, true)\n  // }\n\n  ///////////////////////////////////////\n  // Do Local Hold.\n  // Create and send a Hold offer to WRG which will forward it to the remote client.\n  // Unlike the UCC WRG, the Consumer WRG does not send MOH offer, so we do not have\n  // to wait for MOH before declaring the client is ON-Hold\n  //\n  // If this Hold operation is for 'Inactive' mode, then there will be no MOH follow-on offer, so\n  // we can declare the Hold process complete right away\n  ///////////////////////////////////////\n  private doHoldProcess = async (callSession: CallSession, forceInactive: boolean): Promise<void> => {\n    try {\n      const webRtcObj = callSession.webRtcObj\n      callSession.isLocalHold = true\n      const localSdp = await webRtcObj.createOfferForHold(forceInactive)\n      this.logger.log('doHoldProcess: Sending Hold Offer. State: ', webRtcObj.getCurrentLocalSdpDirection())\n      // const resp = await this.sendSdpAndStatus(callSession.callId, localSdp, 'Hold', undefined)\n      const resp = await this.sendCallHold(callSession.callId, localSdp)\n\n      const receiverSessionStatus = resp.data\n      if (!receiverSessionStatus) {\n        throw makeApiError('Bad Response Data. Missing receiverSessionStatus', -1)\n      }\n\n      callSession.muteStateBeforeLocalHold = webRtcObj.getIsMuted()\n      callSession.videoPauseStateBeforeLocalHold = webRtcObj.getIsPaused()\n      webRtcObj.setStatus(receiverSessionStatus.status)\n      webRtcObj.holdOutgoingMedia()\n      await webRtcObj.setRemoteSessionDescriptionFromSdp(receiverSessionStatus.sdp, true)\n    } catch (error) {\n      await callSession.webRtcObj.resetSignalingState('Connected')\n      callSession.isLocalHold = false\n      this.logger.error('doHoldProcess Error: ', extractErrorMessages(error))\n      return Promise.reject(error)\n    }\n  }\n\n  ///////////////////////////////////////\n  // Resumes from Local Hold.\n  // Resume is a single step process.  Just tell WRG server\n  // we are back to 'Connected' State.  There is now websocket confirmation\n  ///////////////////////////////////////\n  private doResumeProcess = async (callSession: CallSession): Promise<void> => {\n    try {\n      const webRtcObj = callSession.webRtcObj\n      const localSdp = await webRtcObj.createOfferForResume(callSession.isRemoteHold)\n      this.logger.log('doResumeProcess: Sending Resume Offer. State: ', webRtcObj.getCurrentLocalSdpDirection())\n      // const resp = await this.sendSdpAndStatus(callSession.callId, localSdp, 'Connected', undefined)\n      const resp = await this.sendCallResume(callSession.callId, localSdp)\n      const receiverSessionStatus = resp.data\n      webRtcObj.setStatus(receiverSessionStatus.status)\n      // Give WebRtc a remote Session Description using the sdp returned here from WRG.\n      // This completes the sdp negotiation process\n      await webRtcObj.setRemoteSessionDescriptionFromSdp(receiverSessionStatus.sdp, true)\n      webRtcObj.toggleCallMute(callSession.muteStateBeforeLocalHold)\n      webRtcObj.toggleCallVideoPaused(callSession.videoPauseStateBeforeLocalHold)\n      callSession.isLocalHold = false\n    } catch (error) {\n      await callSession.webRtcObj.resetSignalingState('Hold')\n      callSession.isLocalHold = true\n      this.logger.error('doResumeProcess Error: ', extractErrorMessages(error))\n      return Promise.reject(error)\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////\n  // WebSocket Message Handler Methods Below Here\n  //////////////////////////////////////////////////////////////////////\n\n  /**\n   * callSessionInvitationHandler\n   * WebSocket message Handler method for 'WS_sessionInvitationNotification' events\n   * @param sessionInvitationNotification\n   */\n  private callSessionInvitationHandler = async (sessionInvitationNotification: any): Promise<void> => {\n    let newCallSession\n    try {\n      const sessionData = sessionInvitationNotification\n      if (!sessionData) {\n        this.logger.warn('callSessionInvitationHandler: Network sent empty sessionData object')\n        return\n      }\n      const sdp = sessionData.sdp\n      const originatorAddress = parseParticipantAddress(sessionData.originatorAddress)\n      const originatorName = sessionData.originatorName\n      const receiverAddress = parseParticipantAddress(sessionData.receiverAddress)\n      const receiverName = sessionData.receiverName\n      const callObjectRef = sessionData.callObjectRef\n      const callType = sessionData.callType\n      const serverCorrelator = sessionData.serverCorrelator || ''\n      const relatedSessionId = ''\n\n      const sessionId = getLastUrlSegment(callObjectRef)\n      const callId = sessionId\n      newCallSession = this.createCallSession(\n        callId,\n        receiverAddress,\n        originatorAddress,\n        originatorName,\n        receiverAddress,\n        receiverName\n      )\n\n      // save new callObjectRefUrl.  Adjust url for possible conference calls so hold/resume will still work.\n      newCallSession.callObjectRefUrl = callObjectRef.replace('/conference/', '/sessions/')\n      newCallSession.lineInfo = receiverAddress\n      newCallSession.sessionId = sessionId\n      newCallSession.serverCorrelator = serverCorrelator\n      newCallSession.webRtcObj.setIsOfferer(false)\n      this.saveCallSession(callId, newCallSession)\n\n      if (!sdp) {\n        // No sdp indicates this incoming call is from a Call Transfer\n        this.isCallTransfer = true\n        newCallSession.webRtcObj.setIsOfferer(true)\n        newCallSession.relatedSessionId = relatedSessionId\n        this.saveCallSession(callId, newCallSession)\n\n        if (['audio', 'video'].includes(callType)) {\n          const isVideo = callType === 'video'\n          newCallSession.webRtcObj.setHasIncomingVideo(isVideo)\n          await this.processNewIncomingCall(newCallSession)\n        } else {\n          this.logger.warn('callSessionInvitationHandler unknown call type: ', callType)\n        }\n        return\n      }\n\n      const includesVideo = newCallSession.webRtcObj.sdpEnabledForVideo(sdp)\n      const includesAudio = sdp.includes('m=audio')\n      if (includesVideo && includesAudio) {\n        newCallSession.webRtcObj.setHasIncomingVideo(true)\n      } else if (includesAudio) {\n        newCallSession.webRtcObj.setHasIncomingVideo(false)\n      } else if (includesVideo && !includesAudio) {\n        newCallSession.webRtcObj.setHasIncomingVideo(true)\n        newCallSession.webRtcObj.setIsSharing(true)\n      }\n\n      this.saveCallSession(callId, newCallSession)\n      newCallSession.webRtcObj.saveInvitationOfferSdp(sdp)\n      await this.sendSessionStatus(newCallSession)\n    } catch (error) {\n      if (newCallSession) {\n        const callId = newCallSession.callId\n        this.removeCallSession(callId)\n        this.onReceivedCallFailed(callId, 3)\n      }\n      this.logger.error('callSessionInvitationHandler Error: ', extractErrorMessages(error))\n    }\n  }\n\n  /**\n   * vvoipSessionTransferNotification\n   * WebSocket message Handler method for 'vvoipSessionTransferNotification' events\n   * @param vvoipSessionTransferNotification\n   */\n  private vvoipSessionTransferHandler = async (vvoipSessionTransferNotification: any): Promise<void> => {\n    try {\n      const transferInfo = vvoipSessionTransferNotification\n      const resourceURL = transferInfo.resourceURL\n      const transferStatus = transferInfo.transferStatus\n      const sessionId = getLastUrlSegment(resourceURL)\n      const foundCallSession = this.findCallSessionBySessionId(sessionId)\n\n      if (!foundCallSession) {\n        this.logger.warn('vvoipSessionTransferHandler: No CallSession found for sessionId', sessionId)\n        return Promise.reject('No CallSession Found')\n      }\n\n      this.logger.log(\n        'vvoipSessionTransferHandler: xfer status update. callId: ',\n        foundCallSession.callId,\n        transferStatus\n      )\n\n      switch (transferStatus) {\n        case 'Successful':\n          foundCallSession.callTransferSuccess = 'success'\n          break\n        case 'Declined':\n          // The receiver declined receiving this transferred call, or\n          // Client was attempting to transfer a call outside of the T-Mobile network\n          foundCallSession.callTransferSuccess = 'fail'\n          const reasonText = transferInfo.reason?.text\n          if (reasonText) {\n            this.logger.warn('vvoipSessionTransferHandler: Call Transfer Declined because: ', reasonText)\n          }\n          break\n        case 'InProgress':\n          break // do nothing\n        default:\n          this.logger.warn('vvoipSessionTransferHandler: unknown call transfer status: ', transferStatus)\n      }\n    } catch (error) {\n      this.logger.error('vvoipSessionTransferHandler Error: ', extractErrorMessages(error))\n      return Promise.reject(error)\n    }\n  }\n\n  /**\n   * Websocket message Handler method for 'WS_sessionStatusNotification' event\n   * @param sessionStatusNotification\n   */\n  private callSessionStatusNotificationHandler = (sessionStatusNotification: any): void => {\n    try {\n      const sessionData = sessionStatusNotification\n      const callObjectRef = sessionData.callObjectRef\n      const sessionId = getLastUrlSegment(callObjectRef)\n      const foundCallSession = this.findCallSessionBySessionId(sessionId)\n      if (!foundCallSession) {\n        this.logger.warn('callSessionStatusNotificationHandler: No CallSession found for Call sessionId', sessionId)\n        return\n      }\n\n      // save new callObjectRefUrl.  Adjust url for possible conference calls so hold/resume will still work.\n      foundCallSession.callObjectRefUrl = callObjectRef.replace('/conference/', '/sessions/')\n      if (sessionData.transferTargetAddress || sessionData.transferTargetName) {\n        // This feature may only be available on UCC network\n        this.onTransferTargetDetails(foundCallSession.callId, sessionData)\n      }\n\n      this.callSessionStatusSubHandler(foundCallSession, sessionData).catch((warning) => {\n        // This Promise catch handler might seem odd within a try-catch block, but\n        // the call to callSessStatusSubHandler is asynchronous the try-catch block\n        // will have been torn down by the time it returns.\n        this.logger.warn('callSessionStatusNotificationHandler: ', extractErrorMessages(warning))\n        return\n      })\n    } catch (error) {\n      this.logger.error('callSessionStatusNotificationHandler Error: ', extractErrorMessages(error))\n    }\n  }\n\n  ///////////////////////////////////////////////\n  private callSessionStatusSubHandler = async (callSession: CallSession, sessionData: any): Promise<void> => {\n    let status = sessionData.status\n    const sdp = sessionData.sdp\n    let responseCode = sessionData.responseCode\n    if (typeof responseCode === 'string') {\n      responseCode = parseInt(responseCode, 10)\n    }\n\n    const offer = sessionData.offer\n    // const answer = sessionData.answer\n    const webRtcObj = callSession.webRtcObj\n    const prevStatus = webRtcObj.getStatus()\n    webRtcObj.setStatus(status)\n\n    if (status === 'Connected') {\n      const currentLocalSdpDirection = webRtcObj.getCurrentLocalSdpDirection()\n      if (currentLocalSdpDirection === 'a=recvonly' || callSession.isRecvAttendedXfer) {\n        status = 'Resume'\n        webRtcObj.setStatus(status)\n      }\n    }\n\n    if (['Terminated', 'SessionCancelled'].includes(status)) {\n      await this.csshTerminated(callSession, responseCode)\n    } else if (status === 'Declined' && responseCode === 486) {\n      await this.csshDeclined(callSession)\n    } else if (status === 'Hold') {\n      await this.csshHold(callSession, sdp, sessionData, prevStatus)\n    } else if (status === 'Resume') {\n      await this.csshResume(callSession, sdp)\n    } else if (status === 'VideoUpgrade') {\n      await this.csshVideoUpGrade(callSession, sdp)\n    } else if (status === 'VideoDowngrade') {\n      await this.csshVideoDownGrade(callSession, sdp)\n      return Promise.resolve()\n    } else {\n      const didProcess = await this.csshCallStatus(callSession, sdp, !!offer, responseCode)\n      if (didProcess) {\n        return Promise.resolve()\n      }\n    }\n\n    if (['Connected', 'Resume', 'VideoDowngrade'].includes(prevStatus) && status === 'Connected') {\n      const newSdp = await webRtcObj.createAnswerForTransfer(sdp)\n      // const resp = await this.sendSdpAndStatus(callSession.callId, newSdp, 'Connected', '200')\n      const resp = await this.sendCallConnected(callSession.callId, newSdp)\n      if (resp.ok) {\n        this.onReceivedCallActive(callSession.callId)\n        return Promise.resolve()\n      }\n      return Promise.reject(resp)\n    }\n\n    if (['Connected', 'InProgress'].includes(status) && [180, 183, 200].includes(responseCode)) {\n      await this.csshConnectedOrInProgress(callSession, sdp, offer, responseCode)\n    } else if (status === 'Proceeding' && responseCode === 183) {\n      await this.csshProceeding(callSession, sdp, offer)\n    }\n  }\n\n  //////////////////////////\n  // WS message call Session Status Handler for 'Terminated' case\n  private csshTerminated = async (callSession: CallSession, responseCode: number): Promise<void> => {\n    const webRtcObj = callSession.webRtcObj\n    if (!webRtcObj.getIsSharing()) {\n      this.clearCallSession(callSession.callId)\n      if (responseCode === 480) {\n        this.onReceivedCallRejected(callSession.callId)\n      } else {\n        this.onReceivedCallEnded(callSession.callId)\n      }\n    } else {\n      // TODO handle isSharing termination\n      webRtcObj.setIsSharing(false)\n    }\n  }\n\n  ////////////////////////\n  private csshDeclined = async (callSession: CallSession): Promise<void> => {\n    const webRtcObj = callSession.webRtcObj\n    if (!webRtcObj.getIsSharing()) {\n      this.clearCallSession(callSession.callId)\n      this.onReceivedCallRejected(callSession.callId)\n    } else {\n      // TODO handle isSharing declined\n      webRtcObj.setIsSharing(false)\n    }\n  }\n\n  /////////////////////////\n  private csshHold = async (\n    callSession: CallSession,\n    remoteSdp: string,\n    sessionData: any,\n    prevStatus: string\n  ): Promise<void> => {\n    // this.logger.log('cssHold callSession: ', callSession, '\\nremoteSdp:\\n', remoteSdp, '\\nprevStatus:', prevStatus)\n\n    // Check for receiving an Attended/Warm Transfer or MT Switch Device scenario,\n    // which is characterized by two successive Hold requests, the second has no sdp\n    if (sessionData.status === 'Hold' && prevStatus === 'Hold' && !remoteSdp) {\n      callSession.isRecvAttendedXfer = true\n      return await this.sendTransferConnectedStatusAttended(callSession)\n    }\n\n    const webRtcObj = callSession.webRtcObj\n    const incomingSdpDirection = sessionData.offer.mediaIndicator.direction\n    this.logger.log('csshHold: Received Offer for Hold.  Direction: ', incomingSdpDirection)\n\n    // // When the current direction is 'a=sendonly' and the incoming Offer is for 'RecvOnly' then\n    // // this is NOT a new offer for remote hold.  Rather this is the Offer for Music On Hold (MOH)\n    // // which comes to this client after this client initiates the Hold process.\n    // // Only signal the Remote Hold event of not either of those conditions\n    // const currentLocalSdpDirection = webRtcObj.getCurrentLocalSdpDirection()\n    // if (currentLocalSdpDirection !== 'a=sendonly' || incomingSdpDirection !== 'RecvOnly') {\n    //   this.logger.log('csshHold: Signalling Remote Hold Offer')\n    //   callSession.isRemoteHold = true\n    //   this.onReceivedCallHold(callSession.callId)\n    // }\n\n    // Create and send our Answer to their Offer\n    const localSdp = await webRtcObj.createAnswerForHold(remoteSdp)\n    this.logger.log('csshHold: Sending Hold Answer to remote Offer. State: ', webRtcObj.getCurrentLocalSdpDirection())\n    // const resp = await this.sendSdpAndStatus(callSession.callId, localSdp, 'Hold', '200')\n    // if (!resp.ok) {\n    //   return Promise.reject(resp)\n    // }\n    await this.sendCallAcceptHold(callSession.callId, localSdp)\n    this.onReceivedCallHold(callSession.callId)\n  }\n\n  /////////////////////////\n  private csshResume = async (callSession: CallSession, remoteSdp: string): Promise<void> => {\n    // this.logger.log('csshResume, callSession: ', callSession, '\\nremoteSdp:\\n', remoteSdp)\n    const callId = callSession.callId\n    const webRtcObj = callSession.webRtcObj\n\n    if (callSession.isRecvAttendedXfer) {\n      callSession.isRecvAttendedXfer = false\n      // Resuming from being transferred to another device via either 'attended transfer' or 'Switch Device'\n      // Save the remote SDP, and set status\n      // The sessionStatusNotification we just received is an 'answer' so set localOfferer to 'true'\n      // so remote SessionDescription will be 'answer'\n      await webRtcObj.setRemoteSessionDescriptionFromSdp(remoteSdp, true)\n    } else {\n      // Normal Remote Offer to Resume from Hold\n      const localSdp = await webRtcObj.createAnswerForResume(remoteSdp, callSession.isLocalHold)\n      this.logger.log(\n        'csshResume: Sending Resume Answer to remote Offer. State: ',\n        webRtcObj.getCurrentLocalSdpDirection()\n      )\n\n      // const resp = await this.sendSdpAndStatus(callId, localSdp, 'Resume', '200')\n      const resp = await this.sendCallAcceptResume(callId, localSdp)\n      if (!resp.ok) {\n        return Promise.reject(resp)\n      }\n    }\n\n    callSession.isRemoteHold = false\n    // Notify of the remote stream to make sure the audio player is connected to it.\n    this.onRemoteStream(callId, webRtcObj.getIncomingMediaStream(), webRtcObj.getHasIncomingVideo())\n    this.onReceivedCallResume(callId)\n  }\n\n  //////////////////////////\n  private csshVideoUpGrade = async (callSession: CallSession, remoteSdp: string): Promise<void> => {\n    callSession.remoteSdp = remoteSdp\n    if (this.cfg.autoAcceptVideoUpgrade?.enabled) {\n      // Auto accept video remote video upgrade request\n      await this.acceptRemoteVideoUpgrade(callSession.callId)\n    } else {\n      // Inform the UI of this video update request, and let the UI accept or reject the video update\n      this.onRemoteVideoUpgradeRequest(callSession.callId)\n    }\n  }\n\n  /////////////////////////\n  // Downgrade the call to audio only\n  private csshVideoDownGrade = async (callSession: CallSession, remoteSdp: string): Promise<void> => {\n    const webRtcObj = callSession.webRtcObj\n    const localSdp = await webRtcObj.createAnswerForDowngradeToAudio(remoteSdp)\n    // await this.sendSdpAndStatus(callSession.callId, localSdp, 'Connected', '200')\n    await this.sendCallUpdate(callSession.callId, localSdp)\n\n    this.onLocalStream(callSession.callId, webRtcObj.getOutgoingMediaStream(), false)\n    this.onRemoteStream(callSession.callId, webRtcObj.getIncomingMediaStream(), false)\n    this.onRemoteVideoDropped(callSession.callId)\n  }\n\n  //////////////////\n  private csshCallStatus = async (\n    callSession: CallSession,\n    remoteSdp: string,\n    remoteOffer: boolean,\n    responseCode: number\n  ): Promise<boolean> => {\n    this.onReceivedCallStatus(callSession.callId, responseCode)\n    if (!remoteSdp && responseCode === 200) {\n      this.onReceivedCallActive(callSession.callId)\n      return Promise.resolve(false)\n    }\n\n    // Check if this 'status' message contains an offer and a change in video state\n    if (remoteSdp && remoteOffer) {\n      const webRtcObj = callSession.webRtcObj\n      const localVideoDirection = webRtcObj.getCurrentVideoDirection()\n      const remoteVideoDirection = webRtcObj.getSdpVideoDirection(remoteSdp)\n      if (localVideoDirection !== remoteVideoDirection) {\n        // The incoming SDP indicates a change in the video\n        const localSdp = await webRtcObj.processVideoChangedSdp(remoteSdp, !remoteOffer, remoteVideoDirection)\n        // await this.sendSdpAndStatus(callSession.callId, localSdp, 'Connected', '200')\n        await this.sendCallUpdate(callSession.callId, localSdp)\n        if (webRtcObj.getHasIncomingVideo()) {\n          this.onRemoteVideoReceived(callSession.callId)\n        }\n        return Promise.resolve(true)\n      }\n    }\n    return Promise.resolve(false)\n  }\n\n  //////////////////////////\n  private csshProceeding = async (callSession: CallSession, sdp: string, offer: string): Promise<void> => {\n    if (!sdp) {\n      return Promise.resolve()\n    }\n    const webRtcObj = callSession.webRtcObj\n\n    if (sdp.includes('m=video 0')) {\n      // We originally offered a video call.  They accepted the call but as audio-only\n      this.onCallDowngradedToAudio(callSession.callId)\n      await webRtcObj.createOfferToRemoveVideo()\n    }\n\n    const iAmOfferer = !offer\n    const sdpRet = await webRtcObj.processProgressSdp(sdp, iAmOfferer)\n    // const resp = await this.sendSdpAndStatus(callSession.callId, sdpRet, 'Proceeding', '183')\n    if (!iAmOfferer) {\n      const resp = await this.sendCallProceeding(callSession.callId, sdpRet)\n      if (!resp.ok) {\n        return Promise.reject(resp)\n      }\n    }\n  }\n\n  //////////////////////\n  private csshConnectedOrInProgress = async (\n    callSession: CallSession,\n    remoteSdp: string,\n    offer: string,\n    responseCode: number\n  ): Promise<void> => {\n    if (remoteSdp) {\n      const webRtcObj = callSession.webRtcObj\n      const iAmOfferer = !offer\n      const localSdp = await webRtcObj.processProgressSdp(remoteSdp, iAmOfferer)\n      if (offer && localSdp) {\n        // const resp = await this.sendSdpAndStatus(callSession.callId, localSdp, 'Connected', '200')\n        const resp = await this.sendCallConnected(callSession.callId, localSdp)\n        if (!resp.ok) {\n          return Promise.reject(makeApiError('Failed to set Connected state', resp.status))\n        }\n        if (responseCode === 200) {\n          this.onReceivedCallActive(callSession.callId)\n        }\n      }\n    }\n  }\n}\n", "/**\n * CallImpl: code implementation of the Call Interface\n */\n\nimport {\n  AudioDeviceInfo,\n  CallDirection,\n  CallListener,\n  CallMedia,\n  CallMediaSide,\n  CallMediaType,\n  CallState,\n  MAX_VOLUME,\n  MIN_VOLUME,\n} from '../../api/Call'\nimport { CallManager } from './CallManager'\nimport { isFunction, MapOf, noop } from '../../common/libs/utils'\nimport { Logger } from '../../common/libs/Logger'\nimport { isEmergencyNumber, removeChar, parseMSISDN } from '../../common/libs/line-utils'\nimport { ToneHelper } from '../utilities/ToneHelper'\nimport { Device } from '../utilities/utils'\nimport { DeviceType } from './WebRtcAPIs'\nimport { CallSession, DaasCallingAPIs } from './DaasCallingAPIs'\nimport { CallManagerConfig } from '../../api/CallManager'\n\nexport { URI } from '../../common/api/commontypes'\nexport { MapOf } from '../../common/libs/utils'\n\n/**\n * API Class for each call\n */\nexport class Call {\n  private callerId: string\n\n  private callManager: CallManager\n\n  private camera: Device\n\n  private cfg: CallManagerConfig\n\n  private daasCallingApis: DaasCallingAPIs\n\n  private readonly direction: CallDirection\n\n  private readonly id: string\n\n  private callMedias: CallMedia[]\n\n  private readonly isConferenceCall: boolean\n\n  private isRingTonePlaying: boolean\n\n  private listeners: CallListener[] = []\n\n  private localLine: string\n\n  private readonly logger: Logger\n\n  private maxCallResponseWaitTimer: number // max time allowed for user or network, to answer or decline a call\n\n  private microphone: Device\n\n  private networkCallId: string\n\n  private origTime: number\n\n  private relatedSessionId: string\n\n  private remoteAudioElement: HTMLAudioElement\n\n  private remoteLine: string\n\n  private serverCorrelator: string\n\n  private speakers: Device\n\n  private state: CallState\n\n  private toneHelper: ToneHelper\n\n  constructor(\n    id: string,\n    initialNetworkCallId: string,\n    direction: CallDirection,\n    initCallMedias: CallMedia[],\n    localLine: string,\n    remoteLine: string,\n    relatedSessionId: string,\n    _instanceId: string,\n    callerId: string,\n    callManager: CallManager,\n    cfg: CallManagerConfig,\n    isConference: boolean = false,\n    serverCorrelator?: string\n  ) {\n    this.daasCallingApis = DaasCallingAPIs.getInstance()\n    this.callManager = callManager\n    this.callerId = callerId\n    this.relatedSessionId = relatedSessionId\n    this.remoteLine = parseMSISDN(remoteLine)\n    this.localLine = parseMSISDN(localLine)\n    this.callMedias = initCallMedias\n    this.direction = direction\n    this.networkCallId = initialNetworkCallId\n    this.id = id\n    this.isConferenceCall = isConference\n    this.serverCorrelator = serverCorrelator\n    this.cfg = cfg\n    this.logger = new Logger('MW-CALL')\n    this.toneHelper = new ToneHelper(this.logger)\n    this.updateState('new')\n    this.origTime = Date.now()\n\n    // Setup for handling no user or network response.  Normally the network will terminate the call if not\n    // answered or declined within 30 seconds.  In some odd cases that does not happen, so as a precaution the\n    // client will automatically terminate the call in 35 seconds.\n    this.maxCallResponseWaitTimer = window.setTimeout(() => {\n      this.logger.log(`Terminating ${this.direction} call due to time-out waiting for user action or network response`)\n      this.end().catch(noop)\n    }, 35 * 1000) // allow the user 30 seconds to answer or decline the call\n\n    this.remoteAudioElement = new Audio()\n    this.remoteAudioElement.autoplay = true\n    this.remoteAudioElement.volume = 1.0\n    this.isRingTonePlaying = false\n\n    this.initializeDevices()\n      .then(() => {\n        const setSinkId = (this.remoteAudioElement as any).setSinkId\n        if (isFunction(setSinkId)) {\n          setSinkId(this.speakers.deviceId).catch(noop)\n        } else {\n          this.logger.error('setSinkId not defined on audioElement')\n        }\n      })\n      .catch(noop)\n  }\n\n  /**\n   * Get the call id value\n   */\n  public getId = (): string => this.id\n\n  /**\n   * Get the call network id value\n   */\n  public getNetworkCallId = (): string => this.networkCallId\n\n  /**\n   * Get the current call state\n   */\n  public getState = (): CallState => this.state\n\n  /**\n   * Get the current call direction\n   */\n  public getDirection = (): CallDirection => this.direction\n\n  /**\n   * Get the caller's Id\n   */\n  public getCallerId = (): string => this.callerId\n\n  /**\n   * Starts a newly created out-going call\n   */\n  public start = (): Promise<void> => {\n    if (this.state !== 'new' || this.direction !== 'outgoing') {\n      const msg = 'Only a new && outgoing call can be started'\n      this.logger.error(msg)\n      return Promise.reject(new Error(msg))\n    }\n\n    const isVideo = false\n    this.logger.log(`call start isVideo:(${isVideo})`)\n    const deviceList = this.getDeviceList()\n    this.logger.log('deviceList', deviceList)\n\n    // Calling startEmergencyCall if the remote line is an emergency phone number\n    if (isEmergencyNumber(this.remoteLine)) {\n      return Promise.reject('Emergency Calls Not Supported')\n    } else {\n      //Calling startCall with a list of constraints that includes desired Devices used for the call\n      // calling from sip:+1 xxx xxx xxxx, MT doesn't get the originator MSISDN\n      // calling from sip: 1 xxx xxx xxxx, MT gets the originator MSISDN\n      return this.daasCallingApis\n        .startCall(\n          this.remoteLine,\n          isVideo,\n          this.networkCallId,\n          this.localLine ? removeChar(parseMSISDN(this.localLine), '+') : undefined,\n          this.relatedSessionId,\n          this.callerId,\n          deviceList\n          // this.isConferenceCall\n        )\n        .then((newCallId: string) => {\n          this.networkCallId = newCallId\n        })\n        .catch((err: Error) => {\n          this.logger.error(`Unable to make call: ${err.message}`)\n          return Promise.reject(err)\n        })\n    }\n  }\n\n  /**\n   * Indicates if this call is a conference call\n   */\n  public isConference = (): boolean => this.isConferenceCall\n\n  /**\n   * Indicates if this call originated externally\n   */\n  public isIncoming = (): boolean => this.direction === 'incoming'\n\n  /**\n   * Indicates if this call originated internally\n   */\n  public isOutgoing = (): boolean => this.direction === 'outgoing'\n\n  /**\n   * Indicates if the call has audio media\n   */\n  public hasAudio = (): boolean => this.hasMedia('incoming', 'audio')\n\n  /**\n   * Get the in-coming or out-going media stream\n   * @param side: CallMediaSide\n   * @param mediaType: CallMediaType\n   */\n  public getMediaStream = (side: CallMediaSide, mediaType: CallMediaType): MediaStream => {\n    const callSession = this.getCallSession()\n    let stream\n    if (side === 'LOCAL') {\n      stream = callSession.webRtcObj.getOutgoingMediaStream()\n    } else {\n      stream = callSession.webRtcObj.getIncomingMediaStream()\n    }\n    const tracks = mediaType === 'audio' ? stream.getAudioTracks() : stream.getVideoTracks()\n    if (tracks.length > 0) {\n      return stream\n    }\n    return undefined\n  }\n\n  /**\n   * Indicates if the media stream is available\n   * @param side: CallMediaSide\n   * @param media: CallMediaType\n   */\n  public isMediaStreamAvailable = (side: CallMediaSide, media: CallMediaType): boolean => {\n    return !!this.getMediaStream(side, media)\n  }\n\n  /**\n   * returns the value of the Remote Line\n   */\n  public getRemoteLine = (): string => this.remoteLine\n\n  /**\n   *\n   * @param line\n   */\n  public setRemoteLine = (line: string): void => {\n    if (line) {\n      this.remoteLine = parseMSISDN(line)\n    }\n  }\n\n  /**\n   *\n   */\n  public getLocalLine = (): string => this.localLine\n\n  /**\n   *\n   */\n  public getSpeakers = (): Device => this.speakers\n\n  /**\n   *\n   */\n  public getMicrophone = (): Device => this.microphone\n\n  /**\n   * Answer this incoming call.\n   * @param acceptIncomingVideo (optional boolean. defaults to 'false') If true, Answers an incoming video to allow video\n   * if false, Answers the call as Audio Only\n   * @param provideOutgoingVideo (optional boolean. defaults to 'false') If true, and if the incoming call is video,\n   * then makes the call a full, two-way video call.  N/A if 'acceptIncomingVideo' is false.\n   */\n  public answer = (acceptIncomingVideo: boolean = false, provideOutgoingVideo: boolean = false): Promise<void> => {\n    if (this.maxCallResponseWaitTimer) {\n      window.clearTimeout(this.maxCallResponseWaitTimer)\n      this.maxCallResponseWaitTimer = undefined\n    }\n\n    this.updateState('connected')\n\n    // Calling wrgCallAccept with a list of constraints that includes desired Devices used for the call\n    return this.daasCallingApis.acceptCall(\n      this.networkCallId,\n      this.getDeviceList(),\n      acceptIncomingVideo,\n      provideOutgoingVideo\n    )\n  }\n\n  /**\n   * end this current call.\n   */\n  public end = (): Promise<void> => {\n    this.logger.log('end call')\n    return this.endCall(false, true)\n  }\n\n  /**\n   * Put call on hold\n   * Adjust 'held' state to possibly reflect also being on hold from the other party\n   */\n  public hold = (): Promise<void> => {\n    return this.daasCallingApis.holdCall(this.networkCallId).then(() => {\n      if (this.state === 'held_remotely') {\n        this.updateState('held_both')\n      } else if (this.state === 'connected') {\n        this.updateState('held_locally')\n      }\n    })\n  }\n\n  /**\n   * Resume from hold\n   * Adjust 'held' state to possibly reflect still being on hold from the other party\n   */\n  public resume = (): Promise<void> => {\n    return this.daasCallingApis.resumeCall(this.networkCallId).then(() => {\n      if (this.state === 'held_both') {\n        this.updateState('held_remotely')\n      } else if (this.state === 'held_locally') {\n        this.updateState('connected')\n      }\n    })\n  }\n\n  /**\n   * Mute the current microphone on this call\n   */\n  public mute = (): Promise<void> => {\n    return this.daasCallingApis.muteCall(this.networkCallId)\n  }\n\n  /**\n   * Unmute the current microphone on this call\n   */\n  public unmute = (): Promise<void> => {\n    return this.daasCallingApis.unmuteCall(this.networkCallId)\n  }\n\n  /**\n   * Indicates if this call is currently muted locally\n   */\n  public isMuted = (): boolean => {\n    return this.daasCallingApis.isCallMuted(this.networkCallId)\n  }\n\n  /**\n   * Sends a string of one or more DTMF codes\n   * DTMF codes can contain 0-9, '*', '#', ','\n   */\n  public sendDTMF = async (dtmfCodes: string): Promise<void> => {\n    const resp = this.daasCallingApis.sendDtmfCodes(this.networkCallId, dtmfCodes, this.playDtmfTone)\n    if (resp.ok) {\n      return Promise.resolve()\n    }\n    this.logger.warn('Error trying to send DTMF Codes: ', resp.status)\n    return Promise.reject(resp)\n  }\n\n  /**\n   *\n   * @param listener\n   */\n  public addCallListener = (listener: CallListener): void => {\n    this.listeners.push(listener)\n  }\n\n  /**\n   *\n   * @param code\n   */\n  public failureStatusReceived = (code: number): Promise<void> => {\n    if (this.callHasEnded()) {\n      // Call already disconnected or failed.\n      return Promise.resolve()\n    }\n    this.logger.warn(`Call failed: ${code}`)\n    // sendSystemMetric('CALL_FAILED', code)\n    return this.endCall(true, false)\n  }\n\n  /**\n   *\n   * @param statusCode\n   */\n  public callStatusChanged = (statusCode: number): void => {\n    if (this.callHasEnded()) {\n      this.logger.log('callStatusChanged: Call has already ended.  Will not process status change')\n      return\n    }\n\n    this.logger.log(`callStatusChanged got statusChanged: ${statusCode}, processing`)\n\n    switch (String(statusCode)) {\n      case '180':\n      case '183':\n        if (['new'].includes(this.state)) {\n          this.updateState('inprogress')\n          if (this.direction === 'outgoing') {\n            this.startRingback().catch(noop)\n          }\n        } else {\n          this.logger.log('Call already in the inprogress state.  Ignoring status change.')\n        }\n        break\n      case '200':\n        this.updateState('connected')\n        break\n      default:\n        this.logger.error('Unhandled callStatusChanged:', statusCode)\n      // sendSystemError({ error: msg }, { service: CALLING, function: 'callStatusChanged' })\n    }\n  }\n\n  /**\n   *\n   */\n  public getServerCorrelator = (): string => {\n    return this.serverCorrelator\n  }\n\n  /**\n   * remove speaker Id because speakers undefined\n   */\n  public startRingback = (): Promise<void> => {\n    this.logger.log('startRingback')\n    return this.toneHelper\n      .startTone(\n        'ringback',\n        this.callManager.getRingbackToneURL(),\n        this.callManager.getRingToneSpeakers(),\n        this.callManager.getRingbackToneVolume()\n      )\n      .catch((err) => {\n        const msg = `startTone in startRingback rejected with ${err}`\n        this.logger.warn(msg)\n        return Promise.resolve() // swallow the error\n      })\n  }\n\n  /**\n   * Halts the ringback tone playing\n   */\n  public stopRingback = (): void => {\n    this.logger.log('stopRingback')\n    return this.toneHelper.stopTone('ringback')\n  }\n\n  /**\n   * Starts the incoming call ringtone\n   */\n  public startRingtone = (): Promise<void> => {\n    this.logger.log('startRingtone')\n    if (this.isRingTonePlaying || !['new', 'inprogress'].includes(this.state)) {\n      return Promise.resolve()\n    }\n    return this.toneHelper\n      .startTone(\n        'ringtone',\n        this.callManager.getRingToneURL(),\n        this.callManager.getRingToneSpeakers(),\n        this.callManager.getRingbackToneVolume()\n      )\n      .then(() => {\n        this.isRingTonePlaying = true\n      })\n      .catch((err) => {\n        const msg = `startTone in startRingtone rejected with ${err}`\n        this.logger.warn(msg)\n        return Promise.resolve() // swallow the error\n      })\n  }\n\n  /**\n   * Stops the incoming call ringtone\n   */\n  public stopRingtone = (): void => {\n    this.logger.log('stopRingtone')\n    this.toneHelper.stopTone('ringtone')\n    this.isRingTonePlaying = false\n  }\n\n  /**\n   * @internal\n   * @param serverCorrelator\n   */\n  public receivedCallActive = (serverCorrelator?: string): void => {\n    if (this.isOutgoing()) {\n      this.serverCorrelator = serverCorrelator ? serverCorrelator : ''\n    }\n    this.updateState('connected')\n  }\n\n  /**\n   * @internal\n   * Handles the receipt of a new local (preview) stream, but only conveys the\n   * event if the stream has video tracks\n   * @param stream\n   */\n  public onLocalStream = (stream: MediaStream, hasVideo: boolean): void => {\n    this.logger.log('onReceivedLocalStream:', stream, hasVideo)\n    for (const cl of this.listeners) {\n      if (isFunction(cl.onLocalStream)) {\n        setTimeout(() => cl.onLocalStream(this, stream, hasVideo), 1)\n      }\n    }\n    const hasOutgoingVideoMedia = this.hasMedia('outgoing', 'video')\n    const media: CallMedia = { direction: 'outgoing', mediaType: 'video' }\n    if (hasVideo && !hasOutgoingVideoMedia) {\n      this.addMedia(media)\n      for (const cl of this.listeners) {\n        if (isFunction(cl.onMediaAdded)) {\n          setTimeout(() => cl.onMediaAdded(this, media), 1)\n        }\n      }\n    } else if (!hasVideo && hasOutgoingVideoMedia) {\n      this.removeMedia(media)\n      for (const cl of this.listeners) {\n        if (isFunction(cl.onMediaRemoved)) {\n          setTimeout(() => cl.onMediaRemoved(this, media), 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * Handles the receipt of a new remote stream\n   * @param stream\n   */\n  public onRemoteStream = (stream: MediaStream, hasVideo: boolean): void => {\n    this.logger.log('onReceivedRemoteStream:', stream, hasVideo)\n    // Audio is always rendered here\n    this.remoteAudioElement.srcObject = stream\n    const audioTracks = stream.getAudioTracks()\n    if (audioTracks.length) {\n      audioTracks.forEach((track) => (track.enabled = true))\n    } else {\n      this.logger.warn('Remote stream has no audio tracks')\n    }\n\n    // Signal the listeners of the new remote stream\n    this.notifyListeners((cl: CallListener) => {\n      if (isFunction(cl.onRemoteStream)) {\n        setTimeout(() => cl.onRemoteStream(this, stream, hasVideo), 1)\n      }\n    })\n\n    const hasIncomingVideoMedia = this.hasMedia('incoming', 'video')\n    const media: CallMedia = { direction: 'incoming', mediaType: 'video' }\n    if (hasVideo && !hasIncomingVideoMedia) {\n      this.addMedia(media)\n      for (const cl of this.listeners) {\n        if (isFunction(cl.onMediaAdded)) {\n          setTimeout(() => cl.onMediaAdded(this, media), 1)\n        }\n      }\n    } else if (!hasVideo && hasIncomingVideoMedia) {\n      this.removeMedia(media)\n      for (const cl of this.listeners) {\n        if (isFunction(cl.onMediaRemoved)) {\n          setTimeout(() => cl.onMediaRemoved(this, media), 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Attempts to reconnect a call that has been lost due to network\n   * connectivity loss (then resumption)\n   * returns true if call was successfully reconnected\n   */\n  public reconnectCall = (): Promise<boolean> => {\n    return this.daasCallingApis.reconnectCall(this.networkCallId)\n  }\n\n  /**\n   * @internal\n   */\n  public callRejectedRemotely = (): Promise<void> => this.callEndedRemotely()\n\n  /**\n   * @internal\n   */\n  public callEndedRemotely = (): Promise<void> => {\n    if (!this.callHasEnded()) {\n      this.logger.info('Other Party Ended the Call')\n      return this.endCall(false, false)\n    }\n    return Promise.resolve()\n  }\n\n  /**\n   * @internal\n   * Notifies of other party putting us on hold\n   */\n  public receivedCallHold = (): void => {\n    if (this.state === 'held_locally') {\n      this.updateState('held_both')\n    } else if (this.state === 'connected') {\n      this.updateState('held_remotely')\n    }\n  }\n\n  /**\n   * @internal\n   * Notifies of other party resuming our call\n   */\n  public receivedCallResume = (): void => {\n    if (this.state === 'held_both') {\n      this.updateState('held_locally')\n    } else if (this.state === 'held_remotely') {\n      this.updateState('connected')\n    }\n  }\n\n  /**\n   * @internal\n   */\n  public mediaRemovedRemotely = (removedMediaType: CallMediaType): void => {\n    const media: CallMedia = { direction: 'incoming', mediaType: removedMediaType }\n    this.removeMedia(media)\n    this.notifyListeners((cl) => {\n      if (isFunction(cl.onMediaRemoved)) {\n        window.setTimeout(() => cl.onMediaRemoved(this, media), 0)\n      }\n    })\n  }\n\n  /**\n   * @internal\n   */\n  public mediaAddedRemotely = (addedMediaType: CallMediaType): void => {\n    const media: CallMedia = { direction: 'incoming', mediaType: addedMediaType }\n    this.addMedia(media)\n    this.notifyListeners((cl) => {\n      if (isFunction(cl.onMediaRemoved)) {\n        window.setTimeout(() => cl.onMediaAdded(this, media), 0)\n      }\n    })\n  }\n\n  // /**\n  //  * @internal\n  //  */\n  // public onVideoUpgradeRequested = (): void => {\n  //   this.notifyListeners((cl) => {\n  //     if (isFunction(cl.onVideoUpgradeRequested)) {\n  //       window.setTimeout(() => cl.onVideoUpgradeRequested(this), 0)\n  //     }\n  //   })\n  // }\n\n  /**\n   * @internal\n   * @param status\n   */\n  public transferStatusChanged = (status: 'fail' | 'ok'): void => {\n    this.notifyListeners((cl: CallListener) => {\n      if (isFunction(cl.onTransferStatusChanged)) {\n        window.setTimeout(() => cl.onTransferStatusChanged(this, status), 1)\n      }\n    })\n  }\n\n  /**\n   * Gets the HTMLAudioElements used for ringTone and ringbackTone\n   */\n  public getAudioElements = (): MapOf<HTMLAudioElement> => this.toneHelper.audioElements\n\n  /**\n   * Gets the underlying RTCPeerConnection for this call.\n   */\n  public getRTCPeerConnection = (): RTCPeerConnection => {\n    const callSession = this.getCallSession()\n    if (!callSession) {\n      return undefined\n    }\n    return callSession.webRtcObj.getPeerConnection()\n  }\n\n  /**\n   * Allows the call to continue to connect, but halts audio/visual notifications\n   */\n  public ignoreCall = (): void => {\n    if (this.getNetworkCallId()) {\n      this.updateState('ignore')\n    }\n  }\n\n  /**\n   * Select the microphone for this call, by deviceId value\n   * @param newDeviceId\n   */\n  public setMicrophone = (newDeviceId: string): Promise<void> => {\n    return this.getDeviceById('audioinput', newDeviceId)\n      .then((device: Device) => {\n        this.microphone = device\n        const currentMicMuteState = this.isMuted()\n        return this.updateMediaDevice('audioinput', newDeviceId).then(() => {\n          this.logger.log(`Updated Audio Input to use Microphone: ${device.label}`)\n          // Be sure to observe the current mute state when changing the audio input selection\n          if (currentMicMuteState) {\n            return this.mute()\n          } else {\n            return Promise.resolve()\n          }\n        })\n      })\n      .catch((err) => {\n        const errMsg = 'setMicrophone: Error occurred'\n        this.logger.error(errMsg, err)\n        return Promise.reject(errMsg)\n      })\n  }\n\n  /**\n   * Select the Speakers to use for this call, by deviceId\n   * @param newDeviceId\n   */\n  public setSpeakers = (newDeviceId: string): Promise<void> => {\n    return this.getDeviceById('audiooutput', newDeviceId)\n      .then((device: Device) => {\n        this.speakers = device\n        const setSinkId = (this.remoteAudioElement as any).setSinkId\n        if (isFunction(setSinkId)) {\n          return setSinkId(newDeviceId).then(() => {\n            this.logger.log(`Updated Audio Output to use Speakers: ${device.label}`)\n          })\n        } else {\n          const errMsg = 'setSinkId not defined on audioElement'\n          this.logger.warn(errMsg)\n          return Promise.reject(errMsg)\n        }\n      })\n      .catch((err) => {\n        const errMsg = 'setSpeakers: Error occurred'\n        this.logger.error(errMsg, err)\n        return Promise.reject(errMsg)\n      })\n  }\n\n  /**\n   * Get the call speaker volume.  Returns a number between 0 and 100 inclusive.\n   */\n  public getSpeakerVolume = (): number => {\n    return this.remoteAudioElement.volume * MAX_VOLUME // scale to (0 to 100)\n  }\n\n  /**\n   * Set the speaker volume level.  This volume control is a subset of the system master volume control\n   * and can range from 0 to 100% of the current master volume level\n   * @param volumeLevel: number between 0 and 100\n   */\n  public setSpeakerVolume = (volumeLevel: number): void => {\n    if (volumeLevel < MIN_VOLUME) {\n      volumeLevel = MIN_VOLUME\n    } else if (volumeLevel > MAX_VOLUME) {\n      volumeLevel = MAX_VOLUME\n    }\n    this.remoteAudioElement.volume = volumeLevel / MAX_VOLUME\n  }\n\n  /**\n   * Get the list of currently available audio input and output device groups\n   * Typically audio devices come in pairs (speakers and mic), so our search is for audioOutput devices only\n   * We return the groupId value, which can then be used later to select speakers and microphone.\n   * If not running through HTTPS browser session, the entry labels will be blank\n   * returns AudioOutputDeviceInfo[]\n   */\n  public getAvailableAudioDevices = (): Promise<AudioDeviceInfo[]> => {\n    return navigator.mediaDevices\n      .enumerateDevices()\n      .then((results) => results.filter((res) => res.kind === 'audiooutput'))\n      .then((speakerList) => {\n        const devList: AudioDeviceInfo[] = []\n        let defaultGroupId\n        let currentlyActiveGroupId\n        for (const sl of speakerList) {\n          if (sl.deviceId === 'default') {\n            defaultGroupId = sl.groupId\n          }\n          if (this.speakers && this.speakers.deviceId === sl.deviceId) {\n            currentlyActiveGroupId = sl.groupId\n          }\n          if (sl.deviceId !== 'default' && !devList.find((dl) => dl.groupId === sl.groupId)) {\n            devList.push({\n              groupId: sl.groupId,\n              label: sl.label,\n              isCurrentSelection: false,\n            })\n          }\n        }\n        for (const dl of devList) {\n          if (currentlyActiveGroupId) {\n            if (dl.groupId === currentlyActiveGroupId) {\n              dl.isCurrentSelection = true\n              break\n            }\n          } else {\n            if (dl.groupId === defaultGroupId) {\n              dl.isCurrentSelection = true\n              break\n            }\n          }\n        }\n        return devList\n      })\n  }\n\n  /**\n   * @internal\n   * @param deviceGroupId\n   */\n  public updateAudioPairByGroupId = (deviceGroupId: string): Promise<void> => {\n    return navigator.mediaDevices\n      .enumerateDevices()\n      .then((results) => results.filter((res) => res.deviceId !== 'default'))\n      .then((deviceList) => {\n        let foundDevice = deviceList.find((dl) => dl.groupId === deviceGroupId && dl.kind === 'audioinput')\n        let micProm\n        if (foundDevice) {\n          micProm = this.setMicrophone(foundDevice.deviceId)\n        } else {\n          // If there is not a microphone associated with this audio pair, then use the current default mic\n          micProm = this.getCurrentDefaultMicrophone().then((currentDefaultMicDevice) => {\n            this.logger.log(\n              'Selected audio devices does not include a microphone.  Using current system default microphone: ',\n              currentDefaultMicDevice.label\n            )\n            return this.setMicrophone(currentDefaultMicDevice.deviceId)\n          })\n        }\n        foundDevice = deviceList.find((dl) => dl.groupId === deviceGroupId && dl.kind === 'audiooutput')\n        let speakerProm\n        if (foundDevice) {\n          speakerProm = this.setSpeakers(foundDevice.deviceId)\n        }\n        return Promise.all([micProm, speakerProm]).then(() => {\n          // sendSystemMetric('audioDeviceChange', { device: foundDevice.label })\n          return Promise.resolve()\n        })\n      })\n      .catch((err) => {\n        this.logger.error('updateAudioPairByGroupId error updating audio devices: ', err)\n        return Promise.reject(err)\n      })\n  }\n\n  /**\n   * Indicates if the call is on hold, either locally, remotely, or both\n   */\n  public isOnHold = (): boolean => ['held_both', 'held_remotely', 'held_locally'].includes(this.getState())\n\n  /**\n   * Indicates the actual hold state: 'held_locally', 'held_remotely', 'held_both', or ''\n   */\n  public getHoldState = (): CallState | '' => {\n    if (this.isOnHold()) {\n      return this.getState()\n    }\n    return ''\n  }\n\n  /**\n   * Indicates if this call is yet connected\n   */\n  public isConnected = (): boolean => ['connected'].includes(this.getState())\n\n  /**\n   * Attempt to 'revive' or restore a call after a momentary network connection loss.\n   * Calls can be restored upto approximately 1 minute of lost network connection\n   * @return {boolean} true if call was restored\n   */\n  public revive = (): Promise<boolean> => {\n    return this.daasCallingApis.reconnectCall(this.networkCallId)\n  }\n\n  // /**\n  //  * Remove a participant from a Conference call that was created through call merging.\n  //  * The participant status will be changed to 'Disconnected'.\n  //  * @param participantMsisdn\n  //  */\n  // public removeConferenceParticipant = (participantMsisdn: string): Promise<ConferenceSession> => {\n  //   if (!this.isConference()) {\n  //     return Promise.reject(makeApiError('Not a Conference call', -1))\n  //   }\n  //   return this.daasCallingApis.removeConferenceCallParty(this.networkCallId, participantMsisdn)\n  // }\n  //\n  // /**\n  //  * Gets the participants in a Conference call created through call merging.\n  //  */\n  // public getConferenceCallParticipants = (): ConferenceParticipant[] => {\n  //   return this.daasCallingApis.getConferenceCallParticipants(this.networkCallId)\n  // }\n\n  /**\n   * returns the time when the call began.\n   * @returns number: time when call started.\n   */\n  public getCallStartTime = (): number => {\n    return this.origTime\n  }\n\n  //////////////////////////////////////////////////////////////\n  // Private methods below here\n  //////////////////////////////////////////////////////////////\n\n  //////////////////////////////\n  private async endCall(callFailed: boolean, endedLocally: boolean): Promise<void> {\n    this.logger.info('End call')\n\n    if (this.callHasEnded()) {\n      return Promise.reject('Not an active call')\n    }\n    this.updateState(callFailed ? 'failed' : 'disconnected')\n    // if (!callFailed) {\n    //   sendSystemMetric('endCall', undefined, { networkCallId: this.networkCallId, endedLocally })\n    // }\n\n    await this.daasCallingApis.endCall(this.networkCallId, endedLocally).catch((error) => {\n      this.logger.log('endCall error: ', error)\n    })\n  }\n\n  ////////////////////////////////////////////\n  private updateState(newState: CallState): void {\n    const oldState = this.state\n    if (['disconnected', 'failed', newState].includes(oldState)) {\n      this.logger.log('updateState already in disconnected or failed')\n      return\n    }\n\n    if (oldState === undefined && newState === 'new') {\n      this.origTime = Date.now()\n    }\n    if (oldState === 'new' && newState === 'inprogress') {\n      const origDuration = (Date.now() - this.origTime) / 1000\n      // sendSystemMetric('Call origination duration', origDuration)\n      this.logger.log(`Call origination duration', ${origDuration}`)\n      this.origTime = 0\n    }\n\n    this.logger.log(`updateState changed from ${this.state} to ${newState}`)\n    this.state = newState\n    if (['connected', 'disconnected', 'failed', 'ignore'].includes(this.state)) {\n      if (this.direction === 'incoming') {\n        this.stopRingtone()\n      } else {\n        this.stopRingback()\n      }\n      if (this.maxCallResponseWaitTimer) {\n        window.clearTimeout(this.maxCallResponseWaitTimer)\n        this.maxCallResponseWaitTimer = undefined\n      }\n    }\n\n    this.notifyListeners((cl: CallListener) => cl.onCallStateChanged(this, oldState))\n  }\n\n  //////////////////////////////////////////\n  private notifyListeners(iterator: (_cl: CallListener) => any): void {\n    this.listeners.forEach((listener: CallListener) => {\n      try {\n        iterator(listener)\n      } catch (err) {\n        const msg = `While notifying listener ${err}`\n        this.logger.error(msg)\n        // sendSystemError({ error: msg }, { service: CALLING, function: 'notifyListeners' })\n      }\n    })\n  }\n\n  /////////////////////////////////////\n  private getDeviceById(deviceType: DeviceType, deviceId: string): Promise<Device> {\n    return navigator.mediaDevices\n      .enumerateDevices()\n      .then((devices) => devices.filter((device) => device.kind === deviceType && device.deviceId === deviceId))\n      .then((devices) => devices[0])\n      .catch((err) => {\n        // sendSystemError({ error: err }, { service: CALLING, function: 'getDeviceById' })\n        return Promise.reject(err)\n      })\n  }\n\n  ////////////////////////////////\n  private getCallSession(): CallSession {\n    let callSession = this.daasCallingApis.getCallSession(this.id)\n\n    if (!callSession) {\n      callSession = this.daasCallingApis.getCallSession(this.networkCallId)\n    }\n    return callSession\n  }\n\n  //////////////////////////////////////////////////////\n  // Provides audio feedback while sending DTMF codes.\n  // The tone played is purely for user feedback, and does not actually impact the DTMF code sent to MT.\n  // This private method must use lambda function to preserve 'this' context\n  // Note - this routine might need to use a buffer or queue in case it gets called\n  // more often than it can play the tone\n  private playDtmfTone = async (dtmfTone: string): Promise<void> => {\n    if (!dtmfTone) {\n      return\n    }\n\n    // Only process the first character of dtmfTone in case of some error where dtmfTone.length is > 1\n    const toneDigit = dtmfTone.charAt(0)\n    const toneFiles = {\n      '*': 'pound.ogg',\n      '#': 'asterisk.ogg',\n      '0': '0.ogg',\n      '1': '1.ogg',\n      '2': '2.ogg',\n      '3': '3.ogg',\n      '4': '4.ogg',\n      '5': '5.ogg',\n      '6': '6.ogg',\n      '7': '7.ogg',\n      '8': '8.ogg',\n      '9': '9.ogg',\n    }\n    const fileForTone = toneFiles[toneDigit]\n    if (!fileForTone) {\n      if (toneDigit === ',') {\n        this.logger.log('playDtmfTone comma delay')\n      } else {\n        this.logger.warn('playDtmfTone invalid dtmf digit: ', dtmfTone)\n      }\n      return\n    }\n    this.logger.log('playDtmfTone playing DTMF digit: ', dtmfTone)\n\n    const urlForTone = `${this.cfg.dtmfFolderURLPrefix}/${fileForTone}`\n\n    const currentlyMuted = this.isMuted()\n    if (!currentlyMuted) {\n      // temporarily mute mic so that it does not pick-up the\n      // DTMF audio tone we play for user feedback to simulate the original touch-tone experience\n      await this.mute().catch(noop)\n    }\n\n    await this.toneHelper\n      .startTone(\n        `dtmf-${toneDigit}`,\n        urlForTone,\n        (this.speakers && this.speakers.deviceId) || 'default',\n        this.callManager.getRingToneVolume(),\n        false,\n        () => {\n          if (!currentlyMuted) {\n            this.unmute().catch(noop)\n          }\n        }\n      )\n      .catch((err) => {\n        this.logger.warn('Could not play DTMF audio tone: ', dtmfTone, err)\n        if (!currentlyMuted) {\n          this.unmute().catch(noop)\n        }\n        return Promise.resolve() // swallow this error\n      })\n  }\n\n  /////////////////////////////\n  private callHasEnded(): boolean {\n    return ['disconnected', 'failed'].includes(this.state)\n  }\n\n  /////////////////////////////\n  private getCurrentDefaultMicrophone(): Promise<MediaDeviceInfo> {\n    return navigator.mediaDevices\n      .enumerateDevices()\n      .then((results) => results.filter((res) => res.kind === 'audioinput' && res.deviceId === 'default'))\n      .then((micList) => micList[0])\n  }\n\n  /////////////////////////////\n  private getDeviceList(): MediaDeviceInfo[] {\n    let deviceList = []\n    if (this.camera) {\n      deviceList.push({\n        deviceId: this.camera.deviceId,\n        groupId: this.camera.groupId,\n        kind: this.camera.kind,\n        label: this.camera.label,\n      } as MediaDeviceInfo)\n    }\n    if (this.microphone) {\n      deviceList.push({\n        deviceId: this.microphone.deviceId,\n        groupId: this.microphone.groupId,\n        kind: this.microphone.kind,\n        label: this.microphone.label,\n      } as MediaDeviceInfo)\n    }\n    if (this.speakers) {\n      deviceList.push({\n        deviceId: this.speakers.deviceId,\n        groupId: this.speakers.groupId,\n        kind: this.speakers.kind,\n        label: this.speakers.label,\n      } as MediaDeviceInfo)\n    }\n\n    // an empty deviceList will cause problems in WrgCallingApi\n    // If there are no defined devices return undefined so WrgCallingApi will use default devices.\n    if (deviceList.length < 1) {\n      deviceList = undefined\n    }\n\n    return deviceList\n  }\n\n  //////////////////////////\n  private initializeDevices(): Promise<void> {\n    return navigator.mediaDevices\n      .enumerateDevices()\n      .then((results) => {\n        this.microphone = results.filter((res) => res.kind === 'audioinput' && res.deviceId === 'default')[0]\n        this.speakers = results.filter((res) => res.kind === 'audiooutput' && res.deviceId === 'default')[0]\n        const cameras = results.filter((res) => res.kind === 'videoinput')\n        if (cameras.length) {\n          const defaultCameras = cameras.filter((camera) => camera.deviceId === 'default')\n          if (defaultCameras.length) {\n            this.camera = defaultCameras[0]\n          } else {\n            const builtInCameras = cameras.filter((camera) => camera.label.includes('built-in'))\n            if (builtInCameras.length) {\n              this.camera = builtInCameras[0]\n            } else {\n              this.camera = cameras[0]\n            }\n          }\n        }\n      })\n      .catch((err) => {\n        this.logger.error('Error setting meeting default audio devices: ', err)\n      })\n  }\n\n  //////////////////////////\n  // Method for switching microphone or camera without having to renegotiate the webRTC connection\n  // Works, provided the new device is similar in bitrate, etc.\n  private updateMediaDevice(kind: DeviceType, deviceId: string): Promise<void> {\n    return this.daasCallingApis.updateMediaDevice(this.networkCallId, kind, deviceId)\n  }\n\n  //////////////////////////\n  private hasMedia(direction: CallDirection, mediaType: CallMediaType): boolean {\n    return !!this.callMedias.find((m) => m.direction === direction && m.mediaType === mediaType)\n  }\n\n  //////////////////////////\n  private addMedia(callMedia: CallMedia): void {\n    if (!this.hasMedia(callMedia.direction, callMedia.mediaType)) {\n      this.callMedias.push(callMedia)\n    }\n  }\n\n  //////////////////////////\n  private removeMedia(callMedia: CallMedia): void {\n    if (this.hasMedia(callMedia.direction, callMedia.mediaType)) {\n      this.callMedias = this.callMedias.filter(\n        (cm) => cm.direction !== callMedia.direction || cm.mediaType !== callMedia.mediaType\n      )\n    }\n  }\n}\n", "/**\n * CallManager Singleton Class\n * Primary interface ta all Calling features.  This class provides the overall management of a collection of calls,\n * and provides a common single point to publish incoming call notification events.\n */\nimport { ConnectionStates } from '../../api/coreSdkTypes'\nimport { URI } from '../../common/api/commontypes'\nimport { formatLineInfo, parseMSISDN, stripPrefix } from '../../common/libs/line-utils'\nimport { generateUUID, isFunction, noop } from '../../common/libs/utils'\nimport { Logger, LoggerConfig, LogLevel } from '../../common/libs/Logger'\n\nimport { CallListener, CallMedia, CallState } from '../../api/Call'\nimport { CallFilterConfig, CallManagerConfig, CallManagerListener } from '../../api/CallManager'\n\nimport { ToneHelper } from '../utilities/ToneHelper'\nimport { CallFilter, fileForTone } from '../utilities/utils'\n\nimport { Call } from './Call'\nimport { DaasCallingAPIs } from './DaasCallingAPIs'\nimport { commonVersion } from '../../common/api/version'\nimport { CoreSdkInterface, NetworkConnectionEvent, RegistrationMgrInterface } from '../../api/cpaasCoreSdkInterfaces'\n\nexport { CallFilter, Device } from '../utilities/utils'\n\nconst MyCallerId = 'CPaaS Virtual Phone'\n\n/**\n * Primary CallManager Singleton Class\n */\nexport class CallManager {\n  private calls: Call[] = []\n\n  private cfg: CallManagerConfig\n\n  private daasCallingApis: DaasCallingAPIs\n\n  private isServiceInitialized: boolean = false\n\n  private listeners: CallManagerListener[] = []\n\n  private readonly logger: Logger\n\n  private regManager: RegistrationMgrInterface\n\n  private static instance: CallManager\n\n  private toneHelper: ToneHelper\n\n  private ringbackToneVolume = 0.5\n\n  private ringToneVolume = 0.5\n\n  private constructor() {\n    const loggerConfig = LoggerConfig.getInstance()\n    let logLevel = LogLevel.warn\n    if (__DEV__) {\n      logLevel = LogLevel.log\n    }\n    loggerConfig.setLogLevel(logLevel)\n    this.logger = new Logger('CALL-MGR')\n    this.logger.log('CallManager constructor')\n  }\n\n  /**\n   * Returns the singleton instance of the CallManager\n   * @returns CallManager Interface\n   */\n  public static getInstance = (): CallManager => {\n    if (!CallManager.instance) {\n      CallManager.instance = new CallManager()\n    }\n    return CallManager.instance\n  }\n\n  /**\n   * Initialize the CallManager Singleton\n   * @param cfg\n   * @param coreSDK\n   */\n  public initialize = (cfg: CallManagerConfig, coreSDK: CoreSdkInterface): Promise<CallManager> => {\n    const coreSdkVersion = coreSDK.getVersion()\n    if (coreSdkVersion !== commonVersion) {\n      const errMsg = 'CallManager and CoreSDK are not the same version'\n      this.logger.error(errMsg)\n      return Promise.reject(new Error(errMsg))\n    }\n\n    const cpaasServiceAccessors = coreSDK.getCpaasServiceAccessors()\n    const regMgr = coreSDK.getRegistrationManager()\n    const wsEventMgr = coreSDK.getWebSocketEventsMgr()\n\n    this.daasCallingApis = DaasCallingAPIs.getInstance()\n    this.daasCallingApis.initialize(cfg, cpaasServiceAccessors, wsEventMgr)\n    this.cfg = cfg\n    this.toneHelper = new ToneHelper(this.logger)\n    this.regManager = regMgr\n    this.registerCallbacks()\n    this.isServiceInitialized = true\n    return Promise.resolve(this)\n  }\n\n  /**\n   * Clears Call Log Data (future feature)\n   */\n  public clearData = (): Promise<void> => {\n    return Promise.resolve()\n  }\n\n  /**\n   * Indicates if this service has been fully initialized\n   */\n  public isInitialized = (): boolean => this.isServiceInitialized\n\n  /**\n   * Performs all necessary call service shut-down and clean up operations.\n   * Typically when the app is logging out the current user\n   */\n  public logoutCleanup = async (): Promise<void> => {\n    await this.endAllCalls(99)\n    this.isServiceInitialized = false\n    this.cfg = undefined\n  }\n\n  /**\n   * Add a callback listener to receive asynchronous notifications for in-coming calls\n   * @param listener\n   */\n  public addCallManagerListener = (listener: CallManagerListener): void => {\n    if (listener) {\n      this.listeners.push(listener)\n    }\n  }\n\n  /**\n   * Get a specific active call by Id value.\n   * First looks for a matching networkId value, and then if not found\n   * looks for a matching localId value.\n   * The localId is generated when the call is first created locally.\n   * When the call is started, it will be assigned a network id value.\n   * Some code might still have the localId value, so both values are kept so all\n   * references can be match.\n   * In-coming calls will always have localId and networkId be the same value.\n   * Only out-going calls with have separate values for localId and networkId.\n   * @param callId\n   */\n  public getCallById = (callId: string): Call => {\n    let call = this.calls.find((c) => c.getNetworkCallId() === callId)\n    if (!call) {\n      call = this.calls.find((c) => c.getId() === callId)\n    }\n    return call\n  }\n\n  /**\n   * Gets a filtered list of calls\n   * @param filterOrConfig\n   */\n  public getCalls = (filterOrConfig: CallFilter | CallFilterConfig): Call[] => {\n    const filter = CallFilter.fromConfig(filterOrConfig)\n    return this.calls.filter((c) => filter.filter(c))\n  }\n\n  /**\n   * Gets the list of current active calls\n   */\n  public getAllCalls = (): Call[] => {\n    return this.calls\n  }\n\n  /**\n   * Get the list of calls that are currently in the 'connected' state\n   */\n  public getConnectedCalls = (): Call[] => {\n    return this.getCalls({ state: 'connected' })\n  }\n\n  /**\n   * Create a new out-going call.  Call still needs to be 'started' before it will begin dialing the indicated number\n   * @param remoteNumber: string, formatted or un-formatted number to dial.\n   * @param localNumber: (optional string), formatted or un-formatted local line to use.  Defaults to first active local line\n   * @param isVideo: boolean, optional, defaults to false.  Set to true to add video\n   * @param relatedSessionId: string, optional, sessionId for call tracking\n   * @param localInstanceId: string, optional, call instance local id value.\n   * @param isConference: boolean, optional, defaults to false. Used to indicate the creation of a conference call\n   */\n  public createOutgoingCall = (\n    remoteNumber: string,\n    localNumber?: string,\n    isVideo?: boolean,\n    relatedSessionId?: string,\n    localInstanceId?: string,\n    isConference?: boolean\n  ): Call => {\n    const regLines = this.getRegisteredCallLines()\n    const localMsisdn = localNumber ? formatLineInfo(parseMSISDN(localNumber)) : regLines[0]\n    const remoteMsisdn = formatLineInfo(parseMSISDN(remoteNumber))\n\n    if (localNumber && !regLines.includes(localMsisdn)) {\n      throw new Error('Local number must be one of the currently registered lines')\n    }\n\n    const callMedia: CallMedia[] = [{ direction: 'outgoing', mediaType: 'audio' }]\n    if (isVideo) {\n      callMedia.push({ direction: 'outgoing', mediaType: 'video' })\n    }\n\n    this.logger.log(`createOutgoingCall from ${localMsisdn} to ${remoteMsisdn}`)\n\n    const newCallId = generateUUID()\n    const call = new Call(\n      newCallId,\n      newCallId,\n      'outgoing',\n      callMedia,\n      localMsisdn,\n      remoteMsisdn,\n      relatedSessionId,\n      localInstanceId,\n      MyCallerId,\n      this,\n      this.cfg,\n      isConference\n    )\n    call.addCallListener(this.callsListener)\n    for (const listener of this.listeners) {\n      if (isFunction(listener.onCallStateChanged)) {\n        setTimeout(() => listener.onCallStateChanged(call, undefined), 1)\n      }\n    }\n\n    this.logger.log('Call created: ', call)\n    // if (!call.isUSSDCall()) {\n      // Add the call to the list of calls, except for USSD calls which will automatically end after connecting.\n      this.calls.push(call)\n    // }\n\n    return call\n  }\n\n  /**\n   * Creates and starts a new out-going call to the indicated number.\n   * @param remoteNumber: string, formatted or un-formatted number to dial.\n   * @param localNumber: (optional string), formatted or un-formatted local line to use.  Defaults to first active local line\n   * @param isVideo: (optional boolean) Set to 'true' to enable out-going video\n   */\n  public startNewCall = async (remoteNumber: string, localNumber?: string, isVideo?: boolean): Promise<Call> => {\n    try {\n      const newCall = this.createOutgoingCall(remoteNumber, localNumber, isVideo)\n      await newCall.start()\n      return Promise.resolve(newCall)\n    } catch (err) {\n      this.logger.warn('startNewCall error', err)\n      return Promise.reject(err)\n    }\n  }\n\n  /**\n   * End all Calls including the main active call and any calls on hold\n   * @param code\n   */\n  public endAllCalls = (code?: number): Promise<void> => {\n    const currentCalls = this.getAllCalls()\n    if (currentCalls && currentCalls.length > 0) {\n      this.logger.log('Drop active calls.  Code: ', code)\n      const endPromises = currentCalls.map((call) => {\n        const callState = call.getState()\n        if (!['disconnected', 'failed'].includes(callState)) {\n          this.logger.log('Dropping call ', call.getId())\n          Number.isInteger(code) && code === 99 ? call.failureStatusReceived(code) : call.end()\n        }\n      })\n      return Promise.all(endPromises).then(() => Promise.resolve())\n    }\n    // no active calls\n    return Promise.resolve()\n  }\n\n  /**\n   * Attempts to revive an active call after a brief network disconnection\n   */\n  public reviveAllCalls = (): void => {\n    const currentCalls = this.getAllCalls()\n    if (currentCalls && currentCalls.length > 0) {\n      this.logger.log('Attempting to Revive calls after loss of network connectivity')\n      currentCalls.forEach((call) => {\n        const callState = call.getState()\n        // Attempt to revive the call if it is not already 'dead'\n        if (!['disconnected', 'failed'].includes(callState)) {\n          this.logger.log('Attempting to Revive call:', call.getId())\n          call.revive().catch(noop)\n        }\n      })\n    }\n    // no active calls\n  }\n\n  /**\n   * Returns the RingBack tone URL\n   */\n  public getRingbackToneURL = (): URI => this.cfg.ringbackToneURL\n\n  /**\n   * Retrieves the current Ringback tone volume.  This is the tone the\n   * user hears when placing a call and waiting for the other party to answer.\n   * Returns a value between 0 to 1\n   */\n  public getRingbackToneVolume = (): number => this.ringbackToneVolume\n\n  /**\n   * Sets the Ringback tone volume.\n   * @param value - should be an integer between 0 to 100\n   */\n  public setRingbackToneVolume = (value: number): void => {\n    this.ringbackToneVolume = Math.max(0, Math.min(100, value)) / 100\n  }\n\n  /**\n   * N/I, Future Feature. For now always returns undefined\n   */\n  public getRingbackToneSpeakers = (): string => undefined\n\n  /**\n   * Returns the URL to the RingTone URL\n   */\n  public getRingToneURL = (): URI => this.cfg.ringToneURL\n\n  /**\n   * Retrieves the current Ringtone volume.  This is the tone the\n   * user hears as an alert for an in-coming call.\n   * Returns a value between 0 to 1\n   */\n  public getRingToneVolume = (): number => this.ringToneVolume\n\n  /**\n   * Sets the Ringtone volume.\n   * @param value - should be an integer between 0 to 100\n   */\n  public setRingToneVolume = (value: number): void => {\n    this.ringToneVolume = Math.max(0, Math.min(100, value)) / 100\n  }\n\n  /**\n   * N/I, Future Feature. For now, always returns undefined.\n   */\n  public getRingToneSpeakers = (): string => undefined\n\n  /**\n   * N/I, Future Feature.  For now, always returns undefined.\n   */\n  public getMicrophoneDevice = (): string => undefined\n\n  /**\n   * N/I, Future Feature.  For now, always returns 1\n   */\n  public getMicrophoneVolume = (): number => 1\n\n  /**\n   * Plays the DTMF tone on local audio for user audible feedback\n   * Does not actually send a DTMF code over the wire.\n   * @param dtmfDigit\n   */\n  public playDialPadKeyTone = (dtmfDigit: string): Promise<void> => {\n    if (dtmfDigit.length === 1 && ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '*', '#'].includes(dtmfDigit)) {\n      const urlForTone = `${this.cfg.dtmfFolderURLPrefix}/${fileForTone(dtmfDigit)}.ogg`\n\n      return this.toneHelper.startTone(`dtmf-${dtmfDigit}`, urlForTone, 'default', this.getRingToneVolume(), false)\n    }\n    return Promise.reject(new Error('input is not a single DTMF digit character'))\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////\n  // Private Methods Below Here\n  //////////////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////\n  // These are the listeners for the Call Objects\n  private callsListener: CallListener = {\n    onCallStateChanged: (changedCall: Call, oldState: CallState) => {\n      // move call to trash if disconnected of failed\n      if (['disconnected', 'failed'].includes(changedCall.getState())) {\n        const idx = this.calls.findIndex((c) => c.getId() === changedCall.getId())\n        if (idx < 0) {\n          // this.logger.log(`Warning: couldn't find call ${call.id}/${call.networkCallId}`);\n          return // call not found, so it's already been handled.\n        } else {\n          this.calls.splice(idx, 1)\n        }\n      }\n      this.logger.log('CallServiceImpl onCallStateChanged: ', this.listeners, oldState, changedCall.getState())\n      for (const listener of this.listeners) {\n        if (isFunction(listener.onCallStateChanged)) {\n          setTimeout(() => listener.onCallStateChanged(changedCall, oldState), 1)\n        }\n      }\n    },\n\n    onLocalStream: (c: Call, stream: MediaStream, hasVideo: boolean) => {\n      for (const listener of this.listeners) {\n        if (isFunction(listener.onLocalStream)) {\n          setTimeout(() => listener.onLocalStream(c, stream, hasVideo), 1)\n        }\n      }\n    },\n\n    onRemoteStream: (c: Call, stream: MediaStream, hasVideo: boolean) => {\n      for (const listener of this.listeners) {\n        if (isFunction(listener.onRemoteStream)) {\n          setTimeout(() => listener.onRemoteStream(c, stream, hasVideo), 1)\n        }\n      }\n    },\n\n    onMediaAdded: (c: Call, media: CallMedia) => {\n      this.listeners.forEach((l) => {\n        if (isFunction(l.onMediaAdded)) {\n          setTimeout(() => l.onMediaAdded(c, media), 1)\n        }\n      })\n    },\n\n    onMediaRemoved: (c: Call, media: CallMedia) => {\n      this.listeners.forEach((l) => {\n        if (isFunction(l.onMediaRemoved)) {\n          setTimeout(() => l.onMediaRemoved(c, media), 1)\n        }\n      })\n    },\n\n    onTransferStatusChanged: (c: Call, newState: 'fail' | 'ok') => {\n      this.listeners.forEach((l) => {\n        if (isFunction(l.onTransferStatusChanged)) {\n          setTimeout(() => l.onTransferStatusChanged(c, newState), 1)\n        }\n      })\n    },\n\n    onTransferDetails: (c: Call, targetUri: string, targetName: string) => {\n      this.listeners.forEach((l) => {\n        if (isFunction(l.onTransferDetails)) {\n          setTimeout(() => l.onTransferDetails(c, targetUri, targetName), 1)\n        }\n      })\n    },\n\n    // onVideoUpgradeRequested: (c: Call) => {\n    //   this.listeners.forEach((l) => {\n    //     if (isFunction(l.onVideoUpgradeRequested)) {\n    //       setTimeout(() => l.onVideoUpgradeRequested(c), 1)\n    //     }\n    //   })\n    // },\n\n    // onConferenceParticipantUpdate: (call: Call, participants: ConferenceParticipant[]) => {\n    //   this.logger.log('Conference Participant update', call, participants)\n    //   this.listeners.forEach((l) => {\n    //     if (isFunction(l.onConferenceParticipantUpdate)) {\n    //       setTimeout(() => l.onConferenceParticipantUpdate(call, participants), 1)\n    //     }\n    //   })\n    // },\n  }\n\n  //////////////////////////////////////////////////////\n  // Register event listener handlers for the low-level network API events published by WrgCallingAPIs\n  private registerCallbacks(): void {\n    this.regManager.addRegManagerListener({ onNetworkConnection: this.networkConnectionEventListener })\n\n    // this.daasCallingApis.subscribe('OnCallDowngradedToAudio', this.onCallDowngradedToAudio, 'call-service')\n    // this.daasCallingApis.subscribe('OnConferenceParticipantUpdate', this.onConferenceParticipantUpdate, 'call-service')\n    this.daasCallingApis.subscribe('OnLocalStream', this.onLocalStream, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallActive', this.onReceivedCallActive, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallEnded', this.onReceivedCallEnd, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallFailed', this.onReceivedCallFailed, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallHold', this.onReceivedCallHold, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallRejected', this.onReceivedCallRejected, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallResume', this.onReceivedCallResume, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedCallStatus', this.onReceivedCallStatus, 'call-service')\n    this.daasCallingApis.subscribe('OnReceivedNewCall', this.onReceivedNewCall, 'call-service')\n    // this.daasCallingApis.subscribe('OnReceivedUpgradeCallToMeeting', , 'call-service')\n    this.daasCallingApis.subscribe('OnRemoteStream', this.onRemoteStream, 'call-service')\n    // this.daasCallingApis.subscribe('OnRemoteVideoDropped', this.onRemoteVideoDropped, 'call-service')\n    // this.daasCallingApis.subscribe('OnRemoteVideoReceived', this.onRemoteVideoReceived, 'call-service')\n    // this.daasCallingApis.subscribe('OnRemoteVideoUpgradeRequest', this.onVideoUpgradeRequested, 'call-service')\n    this.daasCallingApis.subscribe('OnTransferTargetDetails', this.onTransferTargetDetails, 'call-service')\n  }\n\n  // networkConnectionEventListener\n  // Checks if this client has just gone offline while trying to place a call.  If so, terminate that call.\n  // If a call is already connected, then do not terminate now - possibly able to revive the call if the\n  // network connection loss is brief\n  private networkConnectionEventListener = (networkCnctEvent: NetworkConnectionEvent): void => {\n    if (networkCnctEvent?.networkState !== 'onLine') {\n      const activeCalls = this.getAllCalls()\n      for (const call of activeCalls) {\n        if (['new', 'inprogress', 'ringing'].includes(call.getState())) {\n          call.end().catch(noop)\n          this.logger.log('Terminated call ', call.getNetworkCallId(), ' due to loss of network connection')\n        }\n      }\n    }\n  }\n\n  /*\n   * Will call the specified function with the call found by the passed network id\n   *\n   * @param {string} networkCallId\n   * @param {(call: Call) => void} f\n   */\n  private withCallByNetworkId = (networkCallId: string, f: (call: Call) => void): boolean => {\n    const call = this.getCallById(networkCallId)\n    if (call && isFunction(f)) {\n      f(call)\n      return true\n    }\n    this.logger.log(`Couldn't find call for networkCallId: ${networkCallId} or callback function not defined`)\n    return false\n  }\n\n  /*\n   * CallingAPI event callback handler\n   * Called to update conference call participant status\n   * @param conferenceSession\n   */\n  // private onConferenceParticipantUpdate = (conferenceSession: ConferenceSession): void => {\n  //   this.withCallByNetworkId(conferenceSession.callId, (call: Call) => {\n  //     const confSession = Object.assign({}, conferenceSession)\n  //     this.logger.log('wrgOnConferenceParticipantUpdate: ', confSession)\n  //     this.listeners.forEach((l) => {\n  //       if (isFunction(l.onConferenceParticipantUpdate)) {\n  //         l.onConferenceParticipantUpdate(call, confSession.participants)\n  //       }\n  //     })\n  //   })\n  // }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   * @param {number} code\n   */\n  private onReceivedCallFailed = (callId: string, code: number): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      this.logger.warn(\n        `got wrgOnReceivedCallFailed for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}, code:${code}`\n      )\n      call.failureStatusReceived(code).catch(noop)\n      // sendSystemError(\n      //   { error: 'wrgOnReceivedFailureStatus' },\n      //   { details: this.getCallDetailsForReporting(call), code: code }\n      // )\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   * @param {number} statusCode\n   */\n  private onReceivedCallStatus = (callId: string, statusCode: number): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      this.logger.log(\n        `got onReceivedCallStatus for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}, code:${statusCode}`\n      )\n      call.callStatusChanged(statusCode)\n      // sendSystemMetric('onReceivedCallStatus', undefined, this.getCallDetailsForReporting(call))\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   */\n  private onReceivedCallRejected = (callId: string): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      this.logger.log(\n        `got onReceivedCallRejected for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`\n      )\n      call.callRejectedRemotely().catch(noop)\n      // sendSystemMetric('onReceivedCallRejected', undefined, this.getCallDetailsForReporting(call))\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   */\n  private onReceivedCallEnd = (callId: string): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      this.logger.log(`got onReceivedCallEnd for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`)\n      call.callEndedRemotely().catch(noop)\n      // sendSystemMetric('onReceivedCallEnd', undefined, this.getCallDetailsForReporting(call))\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   */\n  private onReceivedCallHold = (callId: string): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      this.logger.log(`got onReceivedCallHold for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`)\n      call.receivedCallHold()\n      // sendSystemMetric('onReceivedCallHold', undefined, this.getCallDetailsForReporting(call))\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   */\n  private onReceivedCallResume = (callId: string): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      this.logger.log(`got onReceivedCallResume for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`)\n      call.receivedCallResume()\n      // sendSystemMetric('onReceivedCallResume', undefined, this.getCallDetailsForReporting(call))\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   *\n   * @param {string} callId\n   * @param {string} serverCorrelator\n   */\n  private onReceivedCallActive = (callId: string, serverCorrelator?: string): void => {\n    this.withCallByNetworkId(callId, (call: Call) => {\n      call.receivedCallActive(serverCorrelator)\n      // sendSystemMetric('onReceivedCallActive', undefined, this.getCallDetailsForReporting(call))\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   * @param sessionId\n   * @param mediaStream\n   */\n  private onLocalStream = (sessionId: string, mediaStream: MediaStream, hasVideo: boolean): void => {\n    this.withCallByNetworkId(sessionId, (call: Call) => {\n      this.logger.log(`got onReceivedLocalStream for ${call.getId()}/${call.getNetworkCallId()} hasVideo=${hasVideo}`)\n      call.onLocalStream(mediaStream, hasVideo)\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   * @param sessionId\n   * @param mediaStream\n   */\n  private onRemoteStream = (sessionId: string, mediaStream: MediaStream, hasVideo: boolean): void => {\n    this.withCallByNetworkId(sessionId, (call: Call) => {\n      this.logger.log(`got onReceivedRemoteStream for ${call.getId()}/${call.getNetworkCallId()} hasVideo=${hasVideo}`)\n      call.onRemoteStream(mediaStream, hasVideo)\n    })\n  }\n\n  // /*\n  //  * DaasCallingAPIs callback for dropping all video\n  //  *\n  //  * @param {string} callId\n  //  */\n  // private onCallDowngradedToAudio = (callId: string): void => {\n  //   this.withCallByNetworkId(callId, (call: Call) => {\n  //     this.logger.log(\n  //       `got onCallDowngradedToAudio for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`\n  //     )\n  //     call.mediaRemovedRemotely('video')\n  //     call.removeVideo().catch()\n  //   })\n  // }\n\n  // /*\n  //  * DaasCallingAPIs callback for remote video track has dropped\n  //  *\n  //  * @param {string} callId\n  //  */\n  // private onRemoteVideoDropped = (callId: string): void => {\n  //   this.withCallByNetworkId(callId, (call: Call) => {\n  //     this.logger.log(\n  //       `got onReceivedCallVideoDropped for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`\n  //     )\n  //     call.mediaRemovedRemotely('video')\n  //   })\n  // }\n\n  // /*\n  //  * CallingAPI event callback handler\n  //  *\n  //  * @param {string} callId\n  //  */\n  // private onRemoteVideoReceived = (callId: string): void => {\n  //   this.withCallByNetworkId(callId, (call: Call) => {\n  //     this.logger.log(\n  //       `got onReceivedCallVideoAdded for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`\n  //     )\n  //     call.mediaAddedRemotely('video')\n  //   })\n  // }\n\n  // /*\n  //  * CallingAPI event callback handler\n  //  *\n  //  * @param {string} callId\n  //  */\n  // private onVideoUpgradeRequested = (callId: string): void => {\n  //   this.withCallByNetworkId(callId, (call: Call) => {\n  //     this.logger.log(\n  //       `got onVideoUpgradeRequested for ${call.getDirection()}/${call.getId()}/${call.getNetworkCallId()}`\n  //     )\n  //     call.onVideoUpgradeRequested()\n  //   })\n  // }\n\n  /**\n   * CallingAPI event callback handler\n   *\n   * @param {string} networkCallId\n   * @param {string} originatorURI\n   * @param {string} originatorName\n   * @param {string} terminator\n   * @param {string} terminatorName\n   * @param {string} serverCorrelator\n   * @param {string} relatedSessionId\n   * @param {boolean} isVideoCall\n   *\n   */\n  private onReceivedNewCall = (\n    networkCallId: string,\n    originatorURI: string,\n    originatorName: string,\n    terminator: string,\n    _terminatorName: string,\n    serverCorrelator: string,\n    relatedSessionId: string,\n    isVideoCall: boolean\n  ): void => {\n    if (this.regManager.getConnectionState() !== ConnectionStates.CONNECTED) {\n      this.logger.warn('Received New Call outside of Registration Connected state')\n      return\n    }\n\n    if (!originatorName) {\n      originatorName = originatorURI\n    }\n\n    let parsedOriginatorName = decodeURIComponent(originatorName.toLocaleLowerCase())\n    if (originatorName.includes('@')) {\n      parsedOriginatorName = parsedOriginatorName.split('@')[0]\n    }\n    parsedOriginatorName = stripPrefix(parsedOriginatorName)\n\n    // TODO captureCName(originatorURI, parsedOriginatorName)\n\n    const localLine = parseMSISDN(terminator)\n    const callMedias: CallMedia[] = isVideoCall\n      ? [\n          // media definitions for a video call\n          { direction: 'incoming', mediaType: 'audio' },\n          { direction: 'incoming', mediaType: 'video' },\n        ]\n      : [{ direction: 'incoming', mediaType: 'audio' }] // media definitions for an audio-only call\n\n    const call = new Call(\n      networkCallId,\n      networkCallId,\n      'incoming',\n      callMedias,\n      localLine,\n      originatorURI,\n      relatedSessionId,\n      undefined,\n      parsedOriginatorName,\n      this,\n      this.cfg,\n      false,\n      serverCorrelator\n    )\n    const callType = isVideoCall ? 'video' : 'audio'\n\n    this.logger.log(`New incoming ${callType} call: `, call)\n    call.addCallListener(this.callsListener)\n    this.calls.push(call)\n    this.listeners.forEach((l) => {\n      if (isFunction(l.onIncomingCall)) {\n        window.setTimeout(() => l.onIncomingCall(call), 1)\n      }\n    })\n  }\n\n  /*\n   * CallingAPI event callback handler\n   * Provides basic details for whom this call has been transferred to: uri and name.\n   * @param callId\n   * @param transferData\n   */\n  private onTransferTargetDetails = (callId: string, transferData: any): void => {\n    if (!callId || !transferData) {\n      return\n    }\n\n    if (['Connected', 'Resume'].includes(transferData.status)) {\n      let transferTargetAddress = transferData.transferTargetAddress\n      if (transferTargetAddress) {\n        transferTargetAddress = transferTargetAddress.replace('sip:', '')\n      }\n      let transferTargetName = transferData.transferTargetName\n      // Sometimes the network returns our own name instead of the name of the new call recipient, but only on DID calls.\n      // Mask this error should it occur.\n      if (!transferTargetName || transferTargetName.toLowerCase() === decodeURIComponent(MyCallerId.toLowerCase())) {\n        transferTargetName = ''\n      }\n\n      // TODO\n      // if (transferTargetAddress && transferTargetName) {\n      //   captureCName(transferTargetAddress, transferTargetName)\n      // }\n\n      this.withCallByNetworkId(callId, (call: Call) => {\n        this.logger.log(\n          `\\r\\ngot onTransferTargetDetails for ${call.getDirection()}/${call.getId()}/${transferTargetAddress}/${transferTargetName}`\n        )\n        this.listeners.forEach((svcListener) => {\n          if (isFunction(svcListener.onTransferDetails)) {\n            svcListener.onTransferDetails(call, transferTargetAddress, transferTargetName)\n          }\n        })\n      })\n    }\n  }\n\n  ///////////////////////////////////////////////////\n  // private getCallDetailsForReporting = (call: Call) => {\n  //   return {\n  //     callState: call.getState(),\n  //     serverCorrelator: call.getServerCorrelator(),\n  //     remoteLine: call.getRemoteLine(),\n  //     networkCallId: call.getNetworkCallId(),\n  //     localLine: call.getLocalLine(),\n  //     direction: call.getDirection(),\n  //   }\n  // }\n\n  ///////////////////\n  private getRegisteredCallLines(): string[] {\n    return this.regManager.getRegisteredMsisdns()\n  }\n}\n", "/*! Copyright (c) 2023 T-Mobile USA */\nimport { commonVersion } from '../common/api/version'\nimport { CallManager } from './calling/CallManager'\n\nexport {\n  CallDirection,\n  CallListener,\n  CallMedia,\n  CallMediaSide,\n  CallMediaType,\n  CallState,\n  AudioDeviceInfo,\n} from '../api/Call'\nexport { CallManagerConfig, CallManagerListener, ConferenceMergeResults, CallFilterConfig } from '../api/CallManager'\nexport { CallFilter, CallManager, Device } from './calling/CallManager'\nexport { Call, URI, MapOf } from './calling/Call'\n\ndeclare global {\n  const __DEV__: boolean\n}\n\n/**\n * This is the overall CallingSDK singleton class.<br>\n * This class provides access to the primary sub-components of CallingSDK: CallManager etc.<br>\n * This class is implemented as a singleton so there will be only ever be one instance at a time.\n */\nexport class CallingSDK {\n  private static instance: CallingSDK\n\n  // private constructor() {}\n\n  /**\n   * Returns an access interface to the one singleton instance of this class\n   * @returns {CallingSDK} Interface\n   */\n  public static getInstance = (): CallingSDK => {\n    if (!CallingSDK.instance) {\n      CallingSDK.instance = new CallingSDK()\n    }\n    return CallingSDK.instance\n  }\n\n  /**\n   * Returns an access interface to the one singleton instance of the Registration Manager\n   */\n  public getCallManager = (): CallManager => {\n    return CallManager.getInstance()\n  }\n\n  /**\n   * Returns the build version number of the CallingSDK module.\n   * All other SDKs use this value to compare with their own build version\n   * to make sure all SDKs are compatible.\n   * @returns {string} the CallingSDK build version\n   */\n  public getVersion = (): string => {\n    return commonVersion\n  }\n}\n"],
  "mappings": "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",
  "names": ["tracks", "sdp", "fileForTone"]
}
